<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术 on 雪国流明</title><link>https://muo123.github.io/categories/%E6%8A%80%E6%9C%AF/</link><description>Recent content in 技术 on 雪国流明</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>muo123</copyright><lastBuildDate>Fri, 13 Jun 2025 11:22:20 +0800</lastBuildDate><atom:link href="https://muo123.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>Hugo 怎么显示北京时间，并添加文章修改时间</title><link>https://muo123.github.io/articles/hugo-%E6%80%8E%E4%B9%88%E6%98%BE%E7%A4%BA%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/</link><pubDate>Fri, 13 Jun 2025 09:14:14 +0800</pubDate><guid>https://muo123.github.io/articles/hugo-%E6%80%8E%E4%B9%88%E6%98%BE%E7%A4%BA%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/</guid><description>&lt;p>在 Hugo 中显示北京时间并添加文章修改时间，可以通过以下方式实现：&lt;/p>
&lt;hr>
&lt;h3 id="步骤">步骤：
&lt;/h3>&lt;h4 id="配置站点时区">&lt;strong>配置站点时区&lt;/strong>
&lt;/h4>&lt;p>在 &lt;code>hugo.toml&lt;/code> 中设置时区为 &lt;code>Asia/Shanghai&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>timeZone = &lt;span style="color:#5af78e">&amp;#39;Asia/Shanghai&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改变部署网站的时区&lt;code>/.github/workflows/deploy.yaml&lt;/code>，根据自己网站调整，下面演示的是部署网站为 Ubuntu 的设置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">deploy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">runs-on&lt;/span>: ubuntu-latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">TZ&lt;/span>: Asia/Shanghai &lt;span style="color:#78787e"># 修改&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="修改时间格式">&lt;strong>修改时间格式&lt;/strong>
&lt;/h4>&lt;p>在 &lt;code>hugo.toml&lt;/code> 中修改 &lt;code>dateFormat&lt;/code> 字段&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[params.dateFormat]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>published = &lt;span style="color:#5af78e">&amp;#34;2006-01-02&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lastUpdated = &lt;span style="color:#5af78e">&amp;#34;2006-01-02 15:04 MST&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>文章时间呈现效果如下
&lt;img src="https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250613/ugFq/718X47/image.png"
loading="lazy"
alt="718X47/image.png"
>&lt;/p>
&lt;h4 id="添加文章最后修改时间">&lt;strong>添加文章最后修改时间&lt;/strong>
&lt;/h4>&lt;p>在文章的首部字段中添加 &lt;code>lastmod&lt;/code> 字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">title&lt;/span>: &lt;span style="color:#5af78e">&amp;#34;文章标题&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">date&lt;/span>: 2023-10-01T08:00:00&lt;span style="color:#ff9f43">+08&lt;/span>:&lt;span style="color:#ff9f43">00&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">lastmod&lt;/span>: 2023-10-05T14:30:00&lt;span style="color:#ff9f43">+08&lt;/span>:&lt;span style="color:#ff9f43">00&lt;/span> &lt;span style="color:#78787e"># 手动指定修改时间&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者在 &lt;code>hugo.toml&lt;/code> 中设置 &lt;code>frontmatter&lt;/code> 如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>enableGitInfo = &lt;span style="color:#ff6ac1">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e"># 文件修改时间配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[frontmatter]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lastmod = [&lt;span style="color:#5af78e">&amp;#39;lastmod&amp;#39;&lt;/span>, &lt;span style="color:#5af78e">&amp;#39;:git&amp;#39;&lt;/span>, &lt;span style="color:#5af78e">&amp;#39;:fileModTime&amp;#39;&lt;/span>, &lt;span style="color:#5af78e">&amp;#39;date&amp;#39;&lt;/span>, &lt;span style="color:#5af78e">&amp;#39;publishDate&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终效果如下：
&lt;img src="https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250613/9bQn/711X53/image.png"
loading="lazy"
alt="711X53/image.png"
>&lt;/p>
&lt;hr></description></item><item><title>关于 Yaml、Toml、Json 三种数据格式的比较</title><link>https://muo123.github.io/articles/%E5%85%B3%E4%BA%8E-yamltomljson-%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83/</link><pubDate>Wed, 11 Jun 2025 19:43:34 +0800</pubDate><guid>https://muo123.github.io/articles/%E5%85%B3%E4%BA%8E-yamltomljson-%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83/</guid><description>&lt;p>TOML、YAML 和 JSON 都是流行的数据序列化格式，用于存储和交换结构化数据，尤其在配置文件中非常常见。它们各有优缺点，适用于不同的场景。下面是它们的详细比较：&lt;/p>
&lt;h2 id="核心特性概述">核心特性概述
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>JSON (JavaScript Object Notation)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>起源：&lt;/strong> 源自 JavaScript，但现在是语言无关的。&lt;/li>
&lt;li>&lt;strong>设计理念：&lt;/strong> 简洁、轻量、易于机器解析和生成，最初主要用于网络数据交换。&lt;/li>
&lt;li>&lt;strong>语法：&lt;/strong> 基于键值对和嵌套结构。使用大括号 &lt;code>{}&lt;/code> 表示对象，方括号 &lt;code>[]&lt;/code> 表示数组。键必须用双引号 &lt;code>&amp;quot;&amp;quot;&lt;/code> 包裹，字符串值也必须用双引号 &lt;code>&amp;quot;&amp;quot;&lt;/code> 包裹。&lt;/li>
&lt;li>&lt;strong>数据类型：&lt;/strong> 字符串、数字、布尔值 (&lt;code>true&lt;/code>/&lt;code>false&lt;/code>)、&lt;code>null&lt;/code>、对象、数组。&lt;/li>
&lt;li>&lt;strong>可读性：&lt;/strong> 对人类相对友好，但嵌套深时括号匹配可能降低可读性。严格的引号和逗号要求有时显得冗余。&lt;/li>
&lt;li>&lt;strong>注释：&lt;/strong> &lt;strong>不支持注释！&lt;/strong> 这是 JSON 在配置文件场景下的最大短板。&lt;/li>
&lt;li>&lt;strong>安全性：&lt;/strong> 相对安全，解析器通常只处理数据，不执行代码（但要注意 &lt;code>eval()&lt;/code> 的危险用法）。&lt;/li>
&lt;li>&lt;strong>工具支持：&lt;/strong> 几乎所有编程语言都有成熟、高性能的原生或第三方解析/序列化库。是 Web API 的事实标准。&lt;/li>
&lt;li>&lt;strong>典型应用：&lt;/strong> Web API 请求/响应、NoSQL 数据库（如 MongoDB）、前端配置（如 &lt;code>package.json&lt;/code>）、简单数据存储。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>YAML (YAML Ain&amp;rsquo;t Markup Language)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>起源：&lt;/strong> 设计目标是比 XML 更人性化，比 JSON 更强大。&lt;/li>
&lt;li>&lt;strong>设计理念：&lt;/strong> 强调&lt;strong>人类可读性&lt;/strong>和&lt;strong>数据表达能力&lt;/strong>。目标是成为一种对所有编程任务都友好的数据格式。&lt;/li>
&lt;li>&lt;strong>语法：&lt;/strong> 使用&lt;strong>缩进&lt;/strong>(通常是空格)来表示层级关系。结构清晰，类似大纲。键值对用冒号 &lt;code>:&lt;/code> 分隔。支持流式风格（类似 JSON）和块式风格（基于缩进）。字符串通常不需要引号（除非包含特殊字符）。支持锚点 (&lt;code>&amp;amp;&lt;/code>) 和别名 (&lt;code>*&lt;/code>) 实现引用复用。&lt;/li>
&lt;li>&lt;strong>数据类型：&lt;/strong> 在 JSON 基础上扩展，支持更丰富的标量类型（日期、时间戳、复数、null 的不同表示等）、更灵活的集合类型。&lt;/li>
&lt;li>&lt;strong>可读性：&lt;/strong> &lt;strong>非常高&lt;/strong>。简洁的缩进结构、无需引号的字符串、支持多行字符串使其看起来像自然文档。注释用 &lt;code>#&lt;/code> 开头。&lt;/li>
&lt;li>&lt;strong>注释：&lt;/strong> &lt;strong>支持注释&lt;/strong> (&lt;code># 这是一个注释&lt;/code>)。&lt;/li>
&lt;li>&lt;strong>安全性：&lt;/strong> &lt;strong>潜在风险较高！&lt;/strong> 某些语言的 YAML 解析器默认支持反序列化任意类（如 Python 的 PyYAML &lt;code>FullLoader&lt;/code>），可能导致代码执行漏洞（如 &lt;code>!!python/object&lt;/code> 标签）。&lt;strong>使用时务必使用安全加载器（如 &lt;code>SafeLoader&lt;/code>）并禁用不安全特性。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>工具支持：&lt;/strong> 主流语言都有库支持，但解析器实现可能更复杂（尤其处理缩进、隐式类型转换时），性能通常比 JSON 解析器稍差。&lt;/li>
&lt;li>&lt;strong>典型应用：&lt;/strong> 复杂配置文件（如 Kubernetes manifests, Docker Compose, Ansible Playbooks, CI/CD pipelines）、数据序列化（强调可读性时）、文档模板。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>TOML (Tom&amp;rsquo;s Obvious, Minimal Language)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>起源：&lt;/strong> 由 GitHub 联合创始人 Tom Preston-Werner 创建，旨在成为一个比 INI 文件更强大但比 YAML 更简单的配置文件格式。&lt;/li>
&lt;li>&lt;strong>设计理念：&lt;/strong> &lt;strong>明确性&lt;/strong>和&lt;strong>最小化歧义&lt;/strong>。目标是成为一种明显、无歧义的配置文件格式。&lt;/li>
&lt;li>&lt;strong>语法：&lt;/strong> 类似 INI 文件，但有更严格和强大的定义。主要结构是键值对 &lt;code>key = &amp;quot;value&amp;quot;&lt;/code> 和表（节）&lt;code>[table_name]&lt;/code>。表可以嵌套 &lt;code>[parent.child]&lt;/code>。支持数组 &lt;code>[...]&lt;/code> 和内联表 &lt;code>{...}&lt;/code>。键和基本字符串通常不需要引号（除非包含特殊字符或空格）。日期时间是一等公民。&lt;/li>
&lt;li>&lt;strong>数据类型：&lt;/strong> 字符串、整数、浮点数、布尔值、日期时间（带时区）、数组、内联表（相当于对象）。&lt;/li>
&lt;li>&lt;strong>可读性：&lt;/strong> &lt;strong>非常高&lt;/strong>。对于键值对和表结构非常直观清晰，尤其适合扁平和中等嵌套深度的配置。结构非常明显。&lt;/li>
&lt;li>&lt;strong>注释：&lt;/strong> &lt;strong>支持注释&lt;/strong> (&lt;code># 这是一个注释&lt;/code>)。&lt;/li>
&lt;li>&lt;strong>安全性：&lt;/strong> &lt;strong>高&lt;/strong>。语法简单明确，解析器通常只处理数据，没有执行代码的机制。&lt;/li>
&lt;li>&lt;strong>工具支持：&lt;/strong> 主流语言都有良好的库支持。解析器相对简单，性能通常很好。&lt;/li>
&lt;li>&lt;strong>典型应用：&lt;/strong> 应用程序配置文件（如 Rust 的 &lt;code>Cargo.toml&lt;/code>, Python 的 &lt;code>pyproject.toml&lt;/code>）、需要明确性和简单性的场景、替代 INI 文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="关键维度对比表">关键维度对比表
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">特性&lt;/th>
&lt;th style="text-align: left">JSON&lt;/th>
&lt;th style="text-align: left">YAML&lt;/th>
&lt;th style="text-align: left">TOML&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>设计目标&lt;/strong>&lt;/td>
&lt;td style="text-align: left">数据交换 (简洁, 机器友好)&lt;/td>
&lt;td style="text-align: left">数据序列化 (强大, 人类友好)&lt;/td>
&lt;td style="text-align: left">配置文件 (明确, 最小歧义)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>可读性&lt;/strong>&lt;/td>
&lt;td style="text-align: left">中等 (括号多, 引号多)&lt;/td>
&lt;td style="text-align: left">&lt;strong>非常高&lt;/strong> (缩进, 少引号, 像文档)&lt;/td>
&lt;td style="text-align: left">&lt;strong>非常高&lt;/strong> (键值对清晰, 表结构)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>语法&lt;/strong>&lt;/td>
&lt;td style="text-align: left">括号 &lt;code>{} []&lt;/code>, 严格引号&lt;/td>
&lt;td style="text-align: left">&lt;strong>缩进&lt;/strong> (空格), 冒号 &lt;code>:&lt;/code>&lt;/td>
&lt;td style="text-align: left">等号 &lt;code>=&lt;/code>, 表 &lt;code>[...]&lt;/code>, 点号 &lt;code>.&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>数据类型&lt;/strong>&lt;/td>
&lt;td style="text-align: left">基础 (字符串, 数字, 布尔, null, 对象, 数组)&lt;/td>
&lt;td style="text-align: left">&lt;strong>丰富&lt;/strong> (基础 + 日期, 时间, 引用, 自定义标量等)&lt;/td>
&lt;td style="text-align: left">基础 + &lt;strong>日期时间&lt;/strong> + 内联表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>注释&lt;/strong>&lt;/td>
&lt;td style="text-align: left">&lt;strong>❌ 不支持&lt;/strong>&lt;/td>
&lt;td style="text-align: left">&lt;strong>✅ 支持&lt;/strong> (&lt;code>#&lt;/code>)&lt;/td>
&lt;td style="text-align: left">&lt;strong>✅ 支持&lt;/strong> (&lt;code>#&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>复杂性/强大性&lt;/strong>&lt;/td>
&lt;td style="text-align: left">简单&lt;/td>
&lt;td style="text-align: left">&lt;strong>非常强大/复杂&lt;/strong>&lt;/td>
&lt;td style="text-align: left">中等 (比 JSON 强, 比 YAML 简单)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>安全性&lt;/strong>&lt;/td>
&lt;td style="text-align: left">高 (通常只解析数据)&lt;/td>
&lt;td style="text-align: left">&lt;strong>⚠️ 需谨慎&lt;/strong> (默认可能不安全)&lt;/td>
&lt;td style="text-align: left">高 (只解析数据)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>解析性能&lt;/strong>&lt;/td>
&lt;td style="text-align: left">&lt;strong>通常最高&lt;/strong> (库高度优化)&lt;/td>
&lt;td style="text-align: left">通常较低 (语法复杂)&lt;/td>
&lt;td style="text-align: left">通常高 (语法相对简单)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>工具支持&lt;/strong>&lt;/td>
&lt;td style="text-align: left">&lt;strong>无处不在&lt;/strong>&lt;/td>
&lt;td style="text-align: left">广泛&lt;/td>
&lt;td style="text-align: left">广泛 (尤其在较新生态)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>典型场景&lt;/strong>&lt;/td>
&lt;td style="text-align: left">API, Web 数据交换, 简单配置&lt;/td>
&lt;td style="text-align: left">&lt;strong>复杂配置&lt;/strong> (K8s, Ansible), 文档&lt;/td>
&lt;td style="text-align: left">&lt;strong>应用配置&lt;/strong> (Cargo, pip), 替代 INI&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>主要优势&lt;/strong>&lt;/td>
&lt;td style="text-align: left">通用性, 速度, Web 标准&lt;/td>
&lt;td style="text-align: left">可读性, 表达能力, 复杂结构&lt;/td>
&lt;td style="text-align: left">可读性, 明确性, 安全性, 简单配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>主要劣势&lt;/strong>&lt;/td>
&lt;td style="text-align: left">无注释, 冗余引号, 嵌套深时难读&lt;/td>
&lt;td style="text-align: left">缩进错误, 安全性风险, 过度复杂&lt;/td>
&lt;td style="text-align: left">嵌套深时不如 YAML 优雅&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="如何选择">如何选择？
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>选择 JSON 如果：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>你需要&lt;strong>最大化的互操作性和通用性&lt;/strong>（尤其是在 Web API 和前后端通信中）。&lt;/li>
&lt;li>你非常注重&lt;strong>解析性能&lt;/strong>。&lt;/li>
&lt;li>你的数据结构相对简单或嵌套不深。&lt;/li>
&lt;li>注释不是必需（或者你可以通过其他方式变通）。&lt;/li>
&lt;li>你处于一个以 JavaScript/Web 为中心的环境。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>选择 YAML 如果：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>人类可读性和可写性&lt;/strong>是你的最高优先级（配置文件需要经常手动编辑）。&lt;/li>
&lt;li>你的配置&lt;strong>非常复杂&lt;/strong>，有深度嵌套、大量重复结构（可用锚点/别名）、需要多行字符串等。&lt;/li>
&lt;li>你需要&lt;strong>丰富的原生数据类型&lt;/strong>（尤其是日期时间）。&lt;/li>
&lt;li>你&lt;strong>需要注释&lt;/strong>。&lt;/li>
&lt;li>你使用的工具链（如 Kubernetes, Ansible, GitLab CI）&lt;strong>原生支持或强制使用 YAML&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>⚠️ 重要提示：&lt;/strong> 务必使用安全加载方式并了解潜在风险！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>选择 TOML 如果：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>你的主要需求是&lt;strong>清晰、明确的配置文件&lt;/strong>。&lt;/li>
&lt;li>你追求&lt;strong>高可读性&lt;/strong>，但觉得 YAML 的缩进规则有时容易出错或过于灵活。&lt;/li>
&lt;li>你需要一个&lt;strong>比 INI 强大得多&lt;/strong>的格式。&lt;/li>
&lt;li>你&lt;strong>需要注释&lt;/strong>。&lt;/li>
&lt;li>你重视&lt;strong>安全性&lt;/strong>和&lt;strong>简单性&lt;/strong>。&lt;/li>
&lt;li>你使用的语言/工具（如 Rust/Cargo, Python/pip/Poetry）&lt;strong>推荐或默认使用 TOML&lt;/strong>。&lt;/li>
&lt;li>你的配置结构以&lt;strong>键值对和表为主&lt;/strong>，嵌套深度适中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>JSON:&lt;/strong> 数据交换之王，性能好，通用性强，无注释是硬伤。&lt;strong>选它用于机器间的数据传递（尤其是 Web）。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>YAML:&lt;/strong> 人类可读性巅峰，表达能力极强，适合复杂配置，但语法复杂且有安全风险需注意。&lt;strong>选它用于需要高可读性和强大表达力的复杂配置（如 DevOps 工具链）。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>TOML:&lt;/strong> 配置文件的“金发姑娘”（刚刚好），明确、易读、安全、支持注释，在扁平和中等嵌套配置中表现最佳。&lt;strong>选它用于应用程序的配置文件（尤其是较新生态的项目）。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>最终选择取决于你的具体需求：是更侧重机器处理、通用性（JSON），还是人类编辑、表达能力（YAML），或是配置的明确性、安全性、简洁性（TOML）。了解它们的差异有助于你在不同场景下做出最佳选择。&lt;/p></description></item><item><title>详细了解 SQL</title><link>https://muo123.github.io/articles/%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3-sql/</link><pubDate>Tue, 10 Jun 2025 19:54:08 +0800</pubDate><guid>https://muo123.github.io/articles/%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3-sql/</guid><description>&lt;p>&lt;strong>SQL (Structured Query Language)&lt;/strong>，它是与关系型数据库进行交互的&lt;strong>标准编程语言&lt;/strong>。&lt;/p>
&lt;h2 id="核心概念">核心概念
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>关系型数据库 (RDBMS):&lt;/strong>
&lt;ul>
&lt;li>SQL 操作的对象是&lt;strong>关系型数据库管理系统&lt;/strong>，如 MySQL, PostgreSQL, Oracle, Microsoft SQL Server, SQLite 等。&lt;/li>
&lt;li>数据以&lt;strong>表&lt;/strong>的形式组织存储，类似于电子表格。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>表 (Table):&lt;/strong>
&lt;ul>
&lt;li>数据库中的基本结构，用于存储特定类型的数据实体（例如：&lt;code>Customers&lt;/code>, &lt;code>Orders&lt;/code>, &lt;code>Products&lt;/code>）。&lt;/li>
&lt;li>一个数据库通常包含多个表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>列 (Column):&lt;/strong>
&lt;ul>
&lt;li>定义表中的属性或字段（例如：在 &lt;code>Customers&lt;/code> 表中，可能有 &lt;code>CustomerID&lt;/code>, &lt;code>FirstName&lt;/code>, &lt;code>LastName&lt;/code>, &lt;code>Email&lt;/code>, &lt;code>City&lt;/code> 等列）。&lt;/li>
&lt;li>每列有特定的数据类型（如整数 &lt;code>INT&lt;/code>, 字符串 &lt;code>VARCHAR&lt;/code>, 日期 &lt;code>DATE&lt;/code>, 布尔值 &lt;code>BOOLEAN&lt;/code> 等）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>行 (Row) / 记录 (Record):&lt;/strong>
&lt;ul>
&lt;li>表中的一条具体数据项（例如：一行代表一个具体的客户信息）。&lt;/li>
&lt;li>每一行在表中应该是唯一的（通常通过主键保证）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>主键 (Primary Key):&lt;/strong>
&lt;ul>
&lt;li>表中一列或一组列，其值能&lt;strong>唯一标识&lt;/strong>表中的每一行（例如：&lt;code>CustomerID&lt;/code>）。不能为 &lt;code>NULL&lt;/code> 且值必须唯一。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>外键 (Foreign Key):&lt;/strong>
&lt;ul>
&lt;li>一个表中的一列（或一组列），其值引用另一个表的&lt;strong>主键&lt;/strong>。用于建立表与表之间的&lt;strong>关系&lt;/strong>（例如：&lt;code>Orders&lt;/code> 表中的 &lt;code>CustomerID&lt;/code> 列是外键，引用 &lt;code>Customers&lt;/code> 表的主键 &lt;code>CustomerID&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="sql-的主要组成部分按功能分类">SQL 的主要组成部分（按功能分类）
&lt;/h2>&lt;p>SQL 语句根据其功能主要分为以下几类：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>DDL (Data Definition Language - 数据定义语言):&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用于&lt;strong>定义、修改和删除数据库结构&lt;/strong>（模式）。&lt;/li>
&lt;li>主要语句：
&lt;ul>
&lt;li>&lt;code>CREATE&lt;/code>: 创建数据库、表、索引、视图等对象。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">CREATE&lt;/span> &lt;span style="color:#ff6ac1">TABLE&lt;/span> Customers (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CustomerID &lt;span style="color:#ff5c57">INT&lt;/span> &lt;span style="color:#ff6ac1">PRIMARY&lt;/span> &lt;span style="color:#ff6ac1">KEY&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FirstName &lt;span style="color:#ff5c57">VARCHAR&lt;/span>(&lt;span style="color:#ff9f43">50&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LastName &lt;span style="color:#ff5c57">VARCHAR&lt;/span>(&lt;span style="color:#ff9f43">50&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Email &lt;span style="color:#ff5c57">VARCHAR&lt;/span>(&lt;span style="color:#ff9f43">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>ALTER&lt;/code>: 修改现有数据库对象的结构（如添加、删除或修改列）。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">ALTER&lt;/span> &lt;span style="color:#ff6ac1">TABLE&lt;/span> Customers &lt;span style="color:#ff6ac1">ADD&lt;/span> &lt;span style="color:#ff6ac1">COLUMN&lt;/span> PhoneNumber &lt;span style="color:#ff5c57">VARCHAR&lt;/span>(&lt;span style="color:#ff9f43">20&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>DROP&lt;/code>: 删除数据库对象（表、索引、视图等）。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">DROP&lt;/span> &lt;span style="color:#ff6ac1">TABLE&lt;/span> OldCustomers;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>TRUNCATE&lt;/code>: 快速删除表中的所有数据（保留表结构），通常比 &lt;code>DELETE&lt;/code> 更快且不记录单个行删除。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">TRUNCATE&lt;/span> &lt;span style="color:#ff6ac1">TABLE&lt;/span> LogEntries;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DML (Data Manipulation Language - 数据操作语言):&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用于&lt;strong>操作数据库表中的实际数据&lt;/strong>（增、删、改）。&lt;/li>
&lt;li>主要语句：
&lt;ul>
&lt;li>&lt;code>INSERT&lt;/code>: 向表中插入新的数据行。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">INSERT&lt;/span> &lt;span style="color:#ff6ac1">INTO&lt;/span> Customers (FirstName, LastName, Email)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">VALUES&lt;/span> (&lt;span style="color:#5af78e">&amp;#39;John&amp;#39;&lt;/span>, &lt;span style="color:#5af78e">&amp;#39;Doe&amp;#39;&lt;/span>, &lt;span style="color:#5af78e">&amp;#39;john.doe@example.com&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>UPDATE&lt;/code>: 修改表中已有的数据行。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">UPDATE&lt;/span> Customers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">SET&lt;/span> Email &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#5af78e">&amp;#39;new.email@example.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">WHERE&lt;/span> CustomerID &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">123&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>DELETE&lt;/code>: 从表中删除数据行。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">DELETE&lt;/span> &lt;span style="color:#ff6ac1">FROM&lt;/span> Customers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">WHERE&lt;/span> CustomerID &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">456&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DQL (Data Query Language - 数据查询语言):&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>主要用于&lt;strong>从数据库中检索数据&lt;/strong>。虽然只有一个核心语句，但它是最常用和最复杂的部分。&lt;/li>
&lt;li>核心语句：
&lt;ul>
&lt;li>&lt;code>SELECT&lt;/code>: 从一个或多个表中查询数据。功能极其强大，包含众多子句：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">SELECT&lt;/span> column1, column2, ... &lt;span style="color:#ff6ac1">|&lt;/span> &lt;span style="color:#ff6ac1">*&lt;/span> &lt;span style="color:#78787e">-- 选择要返回的列 (* 表示所有列)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>&lt;span style="color:#ff6ac1">FROM&lt;/span> &lt;span style="color:#ff6ac1">table_name&lt;/span> &lt;span style="color:#78787e">-- 指定数据来源的表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>[&lt;span style="color:#ff6ac1">WHERE&lt;/span> condition] &lt;span style="color:#78787e">-- 过滤行 (基于指定条件)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>[&lt;span style="color:#ff6ac1">GROUP&lt;/span> &lt;span style="color:#ff6ac1">BY&lt;/span> &lt;span style="color:#ff6ac1">column_name&lt;/span>] &lt;span style="color:#78787e">-- 将结果集按一列或多列分组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>[&lt;span style="color:#ff6ac1">HAVING&lt;/span> condition] &lt;span style="color:#78787e">-- 对分组后的结果集进行过滤 (与 GROUP BY 配合使用)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>[&lt;span style="color:#ff6ac1">ORDER&lt;/span> &lt;span style="color:#ff6ac1">BY&lt;/span> &lt;span style="color:#ff6ac1">column_name&lt;/span> [&lt;span style="color:#ff6ac1">ASC&lt;/span>&lt;span style="color:#ff6ac1">|&lt;/span>&lt;span style="color:#ff6ac1">DESC&lt;/span>]] &lt;span style="color:#78787e">-- 对结果集排序 (ASC 升序, DESC 降序)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>[&lt;span style="color:#ff6ac1">LIMIT&lt;/span> &lt;span style="color:#ff5c57">number&lt;/span>]; &lt;span style="color:#78787e">-- 限制返回的行数
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>关键子句详解 (&lt;code>SELECT&lt;/code>):&lt;/strong>
&lt;ul>
&lt;li>&lt;code>JOIN&lt;/code> (&lt;code>INNER JOIN&lt;/code>, &lt;code>LEFT JOIN&lt;/code> / &lt;code>LEFT OUTER JOIN&lt;/code>, &lt;code>RIGHT JOIN&lt;/code> / &lt;code>RIGHT OUTER JOIN&lt;/code>, &lt;code>FULL JOIN&lt;/code> / &lt;code>FULL OUTER JOIN&lt;/code>, &lt;code>CROSS JOIN&lt;/code>): 用于&lt;strong>组合来自两个或多个表&lt;/strong>的行，基于它们之间的相关列（通常是外键关系）。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">SELECT&lt;/span> Orders.OrderID, Customers.FirstName, Customers.LastName
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">FROM&lt;/span> Orders
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">INNER&lt;/span> &lt;span style="color:#ff6ac1">JOIN&lt;/span> Customers &lt;span style="color:#ff6ac1">ON&lt;/span> Orders.CustomerID &lt;span style="color:#ff6ac1">=&lt;/span> Customers.CustomerID; &lt;span style="color:#78787e">-- 只返回有匹配订单的客户
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>&lt;code>INNER JOIN&lt;/code>:&lt;/strong> 只返回两个表中匹配的行。&lt;/li>
&lt;li>&lt;strong>&lt;code>LEFT (OUTER) JOIN&lt;/code>:&lt;/strong> 返回左表 (FROM 后的表) 的所有行，即使右表中没有匹配。右表不匹配的部分用 &lt;code>NULL&lt;/code> 填充。&lt;/li>
&lt;li>&lt;strong>&lt;code>RIGHT (OUTER) JOIN&lt;/code>:&lt;/strong> 返回右表 (JOIN 后的表) 的所有行，即使左表中没有匹配。左表不匹配的部分用 &lt;code>NULL&lt;/code> 填充。&lt;/li>
&lt;li>&lt;strong>&lt;code>FULL (OUTER) JOIN&lt;/code>:&lt;/strong> 返回左右两表中所有的行。不匹配的部分用 &lt;code>NULL&lt;/code> 填充。&lt;/li>
&lt;li>&lt;strong>&lt;code>CROSS JOIN&lt;/code>:&lt;/strong> 返回两个表的笛卡尔积（所有可能的行组合）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>子查询 (Subquery):&lt;/strong> 嵌套在另一个 &lt;code>SELECT&lt;/code>, &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 语句或另一个子查询中的查询。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">SELECT&lt;/span> CustomerName
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">FROM&lt;/span> Customers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">WHERE&lt;/span> CustomerID &lt;span style="color:#ff6ac1">IN&lt;/span> (&lt;span style="color:#ff6ac1">SELECT&lt;/span> CustomerID &lt;span style="color:#ff6ac1">FROM&lt;/span> Orders &lt;span style="color:#ff6ac1">WHERE&lt;/span> OrderDate &lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> &lt;span style="color:#5af78e">&amp;#39;2023-01-01&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>集合操作 (Set Operations):&lt;/strong> 组合多个 &lt;code>SELECT&lt;/code> 语句的结果集。
&lt;ul>
&lt;li>&lt;code>UNION&lt;/code>: 合并结果集，&lt;strong>自动去除重复行&lt;/strong>。&lt;/li>
&lt;li>&lt;code>UNION ALL&lt;/code>: 合并结果集，&lt;strong>包含所有行（包括重复行）&lt;/strong>。&lt;/li>
&lt;li>&lt;code>INTERSECT&lt;/code>: 返回两个查询结果集的&lt;strong>交集&lt;/strong>（共同存在的行）。&lt;/li>
&lt;li>&lt;code>EXCEPT&lt;/code> (或 &lt;code>MINUS&lt;/code>): 返回第一个查询结果集中&lt;strong>排除&lt;/strong>第二个查询结果集内容后的行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DCL (Data Control Language - 数据控制语言):&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用于&lt;strong>控制数据库访问权限和安全性&lt;/strong>。&lt;/li>
&lt;li>主要语句：
&lt;ul>
&lt;li>&lt;code>GRANT&lt;/code>: 授予用户或角色对数据库对象的特定权限（如 &lt;code>SELECT&lt;/code>, &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>, &lt;code>ALL PRIVILEGES&lt;/code>）。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">GRANT&lt;/span> &lt;span style="color:#ff6ac1">SELECT&lt;/span>, &lt;span style="color:#ff6ac1">INSERT&lt;/span> &lt;span style="color:#ff6ac1">ON&lt;/span> Customers &lt;span style="color:#ff6ac1">TO&lt;/span> user_reporting;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>REVOKE&lt;/code>: 撤销之前授予的权限。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">REVOKE&lt;/span> &lt;span style="color:#ff6ac1">DELETE&lt;/span> &lt;span style="color:#ff6ac1">ON&lt;/span> Orders &lt;span style="color:#ff6ac1">FROM&lt;/span> user_intern;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>TCL (Transaction Control Language - 事务控制语言):&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用于&lt;strong>管理数据库中的事务&lt;/strong>。事务是一组作为单个逻辑工作单元执行的 SQL 语句，要么全部成功，要么全部失败（ACID 特性：原子性、一致性、隔离性、持久性）。&lt;/li>
&lt;li>主要语句：
&lt;ul>
&lt;li>&lt;code>BEGIN TRANSACTION&lt;/code> (或 &lt;code>START TRANSACTION&lt;/code>): 显式开始一个事务。&lt;/li>
&lt;li>&lt;code>COMMIT&lt;/code>: 提交事务，使事务中所有修改永久生效。&lt;/li>
&lt;li>&lt;code>ROLLBACK&lt;/code>: 回滚事务，撤销事务中所有未提交的修改。&lt;/li>
&lt;li>&lt;code>SAVEPOINT&lt;/code>: 在事务内设置保存点，允许部分回滚到该点。&lt;/li>
&lt;li>&lt;code>SET TRANSACTION&lt;/code>: 设置事务特性（如隔离级别）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="sql-的重要特性">SQL 的重要特性
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>声明式语言 (Declarative):&lt;/strong> 你主要描述&lt;strong>你想要什么数据&lt;/strong>（&lt;code>SELECT ... WHERE ...&lt;/code>），而不是像过程式语言那样详细指定计算机如何一步步获取数据。数据库引擎的&lt;strong>查询优化器&lt;/strong>负责找出最高效的执行路径。&lt;/li>
&lt;li>&lt;strong>标准化:&lt;/strong> SQL 有 ANSI/ISO 标准（如 SQL-92, SQL:1999, SQL:2003, SQL:2008, SQL:2011, SQL:2016, SQL:2019），确保了核心语法的通用性。但&lt;strong>不同数据库厂商（如 MySQL, PostgreSQL, Oracle, SQL Server）在实现标准 SQL 的同时，都扩展了自己的特有功能（方言）和数据类型&lt;/strong>。编写可移植的 SQL 需要注意这些差异。&lt;/li>
&lt;li>&lt;strong>强大的查询能力:&lt;/strong> 通过 &lt;code>SELECT&lt;/code> 语句结合 &lt;code>WHERE&lt;/code>, &lt;code>JOIN&lt;/code>, &lt;code>GROUP BY&lt;/code>, &lt;code>HAVING&lt;/code>, 子查询、窗口函数等，可以执行非常复杂的数据检索、聚合和分析操作。&lt;/li>
&lt;li>&lt;strong>数据完整性与安全性:&lt;/strong> 通过约束（主键、外键、唯一约束、非空约束、检查约束）、事务（ACID）和权限控制（DCL）来保证数据的准确、一致和安全。&lt;/li>
&lt;/ul>
&lt;h2 id="sql-的实际应用场景">SQL 的实际应用场景
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>数据检索与分析:&lt;/strong> 这是 SQL 最核心的用途。分析师、数据科学家、产品经理等使用 SQL 从海量数据中提取所需信息，生成报告，进行业务分析。&lt;/li>
&lt;li>&lt;strong>Web 应用后端:&lt;/strong> 几乎所有动态网站（电商、社交网络、内容管理系统）的后端服务器都使用 SQL 数据库存储用户信息、产品数据、订单、帖子等内容，并通过 SQL 进行读写操作。&lt;/li>
&lt;li>&lt;strong>移动应用后端:&lt;/strong> 与 Web 应用类似，移动 App 的数据通常也存储在服务器端的 SQL 数据库中。&lt;/li>
&lt;li>&lt;strong>数据仓库与商业智能 (BI):&lt;/strong> SQL 是查询数据仓库（如 Amazon Redshift, Google BigQuery, Snowflake）和操作 BI 工具（如 Tableau, Power BI, Looker）的基础语言。&lt;/li>
&lt;li>&lt;strong>数据迁移与集成 (ETL):&lt;/strong> 在数据管道中，SQL 常用于从源数据库提取数据、在暂存区转换数据、以及加载到目标数据库或数据仓库。&lt;/li>
&lt;li>&lt;strong>数据库管理:&lt;/strong> DBA（数据库管理员）使用 SQL 进行数据库的创建、维护、性能调优、备份恢复、用户权限管理等。&lt;/li>
&lt;/ol>
&lt;h2 id="学习-sql-的建议">学习 SQL 的建议
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>动手实践:&lt;/strong> 理论学习是基础，但最重要的是动手写 SQL 语句。安装一个数据库（如 MySQL, PostgreSQL 或 SQLite）或使用在线练习平台（如 LeetCode, HackerRank, SQLZoo, Mode Analytics SQL Tutorial, W3Schools SQL）。&lt;/li>
&lt;li>&lt;strong>理解基础:&lt;/strong> 牢固掌握 &lt;code>SELECT&lt;/code>（包括所有关键子句 &lt;code>WHERE&lt;/code>, &lt;code>GROUP BY&lt;/code>, &lt;code>HAVING&lt;/code>, &lt;code>ORDER BY&lt;/code>, &lt;code>LIMIT&lt;/code>）、&lt;code>JOIN&lt;/code>（各种连接的区别）、基本的 &lt;code>INSERT&lt;/code>/&lt;code>UPDATE&lt;/code>/&lt;code>DELETE&lt;/code>。&lt;/li>
&lt;li>&lt;strong>掌握 &lt;code>JOIN&lt;/code>:&lt;/strong> 理解不同 &lt;code>JOIN&lt;/code> 类型（尤其是 &lt;code>INNER JOIN&lt;/code> 和 &lt;code>LEFT JOIN&lt;/code>）的工作原理和应用场景至关重要，因为实际数据通常分布在多个表中。&lt;/li>
&lt;li>&lt;strong>学习聚合与分组:&lt;/strong> &lt;code>GROUP BY&lt;/code> 和聚合函数（&lt;code>COUNT&lt;/code>, &lt;code>SUM&lt;/code>, &lt;code>AVG&lt;/code>, &lt;code>MIN&lt;/code>, &lt;code>MAX&lt;/code>）是数据分析的核心。&lt;/li>
&lt;li>&lt;strong>理解子查询:&lt;/strong> 学会编写和使用子查询来解决复杂问题。&lt;/li>
&lt;li>&lt;strong>熟悉所用数据库的文档:&lt;/strong> 了解你正在使用的特定数据库（MySQL, PostgreSQL 等）的语法细节、数据类型和特有功能。&lt;/li>
&lt;li>&lt;strong>关注性能:&lt;/strong> 学习如何编写高效的 SQL 查询（例如：使用索引、避免 &lt;code>SELECT *&lt;/code>、优化 &lt;code>JOIN&lt;/code> 和 &lt;code>WHERE&lt;/code> 条件）。&lt;code>EXPLAIN&lt;/code> 或 &lt;code>EXPLAIN ANALYZE&lt;/code> 命令是你的好朋友。&lt;/li>
&lt;li>&lt;strong>处理 &lt;code>NULL&lt;/code> 值:&lt;/strong> 理解 &lt;code>NULL&lt;/code> 在比较、计算和聚合中的行为，并学会使用 &lt;code>IS NULL&lt;/code> / &lt;code>IS NOT NULL&lt;/code> 和 &lt;code>COALESCE&lt;/code> / &lt;code>IFNULL&lt;/code> 等函数处理它。&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>SQL 是管理和操作关系型数据库的基石语言。它功能强大、应用广泛，从简单的数据查询到复杂的业务逻辑实现都离不开它。无论是数据分析师、软件工程师、产品经理还是数据库管理员，掌握 SQL 都是一项极具价值的核心技能。其声明式的特性让你专注于“要什么”，而让数据库引擎去解决“怎么拿”的问题，极大地提高了数据处理的效率和便捷性。&lt;/p></description></item><item><title>深入了解MVC架构</title><link>https://muo123.github.io/articles/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mvc%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 09 Jun 2025 21:11:31 +0800</pubDate><guid>https://muo123.github.io/articles/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mvc%E6%9E%B6%E6%9E%84/</guid><description>&lt;img src="https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250609/sDey/743X194/image.png" alt="Featured image of post 深入了解MVC架构" />&lt;p>本文将深入探讨 &lt;strong>MVC (Model-View-Controller)&lt;/strong> 架构模式，特别是在 &lt;strong>iOS开发&lt;/strong> 中的实现、优缺点和演变。&lt;/p>
&lt;p>&lt;strong>MVC 的核心思想：职责分离&lt;/strong>&lt;/p>
&lt;p>MVC 的核心目标是将应用程序的逻辑划分为三个清晰的角色，每个角色有明确的职责，从而降低代码的耦合度，提高可维护性和可测试性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>MyFeature/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Model/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── User.swift // 数据模型
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── DataService.swift // 网络/数据库服务
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── View/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── ProfileView.swift // 自定义视图
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── ProfileCell.swift // TableView单元格
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Controller/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── ProfileViewController.swift // 视图控制器
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="经典-mvc-理论模型">&lt;strong>经典 MVC 理论模型&lt;/strong>
&lt;/h3>&lt;p>&lt;img src="https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250609/Y9Mn/841X108/image.png"
loading="lazy"
alt="841X108/image.png"
>&lt;/p>
&lt;p>&lt;strong>经典 MVC 数据流示意图&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>用户 (User)&lt;/strong> 与 &lt;strong>视图 (View)&lt;/strong> 交互（如点击按钮）。&lt;/li>
&lt;li>&lt;strong>View&lt;/strong> 将用户事件传递给 &lt;strong>控制器 (Controller)&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> 处理逻辑：
&lt;ul>
&lt;li>更新 &lt;strong>模型 (Model)&lt;/strong> 数据（如保存用户输入）。&lt;/li>
&lt;li>从 &lt;strong>Model&lt;/strong> 读取数据（如查询数据库）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Model&lt;/strong> 数据变更后通知 &lt;strong>Controller&lt;/strong>（通过观察者模式等）。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> 将新数据传递给 &lt;strong>View&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>View&lt;/strong> 根据数据更新界面，反馈给用户。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>✅ &lt;strong>理想情况&lt;/strong>：各层职责分离，数据流清晰。&lt;br>
❌ &lt;strong>iOS 现实&lt;/strong>：Controller 常过度承担逻辑，导致臃肿。&lt;/p>&lt;/blockquote>
&lt;h4 id="model-模型">&lt;strong>Model (模型)&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>职责：&lt;/strong> 代表应用程序的核心数据和业务逻辑。&lt;/li>
&lt;li>&lt;strong>包含什么：&lt;/strong>
&lt;ul>
&lt;li>数据结构（例如：&lt;code>User&lt;/code>, &lt;code>Product&lt;/code>, &lt;code>Order&lt;/code> 等类或结构体）。&lt;/li>
&lt;li>数据的操作方法（例如：创建、读取、更新、删除 - CRUD）。&lt;/li>
&lt;li>业务规则和计算逻辑（例如：验证用户输入、计算订单总价）。&lt;/li>
&lt;li>数据持久化操作（例如：与数据库、网络API交互的代码，虽然有时这部分会单独抽象成服务层）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键特性：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>独立于 UI：&lt;/strong> Model 完全不关心数据如何显示或用户如何交互。它只关注数据本身和操作数据的逻辑。&lt;/li>
&lt;li>&lt;strong>通知变更：&lt;/strong> 当 Model 的数据发生改变时，它需要一种机制来通知相关方（通常是 Controller）。在 iOS 中，这通常通过以下几种方式实现：
&lt;ul>
&lt;li>&lt;strong>KVO (Key-Value Observing)：&lt;/strong> 允许对象监听另一个对象特定属性的变化。（较底层，手动管理麻烦）。&lt;/li>
&lt;li>&lt;strong>委托模式 (Delegation)：&lt;/strong> 定义协议，Model 持有对实现了该协议的委托对象（通常是 Controller）的弱引用，并在数据变化时调用委托方法。（常用，但通常是一对一）。&lt;/li>
&lt;li>&lt;strong>通知中心 (NotificationCenter)：&lt;/strong> 广播数据变更事件，任何注册监听的组件都可以响应。（一对多，松散耦合，但需注意内存管理和类型安全）。&lt;/li>
&lt;li>&lt;strong>响应式编程 (Combine/RxSwift)：&lt;/strong> 使用可观察的流来处理数据变更通知。（现代、强大，但学习曲线较陡）。&lt;/li>
&lt;li>&lt;strong>直接调用：&lt;/strong> Controller 在修改 Model 后，直接手动更新 View。（最简单，但耦合度高，容易遗漏）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="view-视图">&lt;strong>View (视图)&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>职责：&lt;/strong> 负责数据的可视化呈现和捕获用户的输入事件。&lt;/li>
&lt;li>&lt;strong>包含什么：&lt;/strong>
&lt;ul>
&lt;li>UI 组件：&lt;code>UIView&lt;/code> 及其子类 (&lt;code>UILabel&lt;/code>, &lt;code>UIButton&lt;/code>, &lt;code>UITableView&lt;/code>, &lt;code>UICollectionView&lt;/code>, &lt;code>UITextField&lt;/code> 等)。&lt;/li>
&lt;li>布局信息：Frame、Auto Layout 约束、Size Classes。&lt;/li>
&lt;li>外观样式：颜色、字体、图片、动画效果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键特性：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>被动：&lt;/strong> 理想情况下，View 本身不应该包含业务逻辑。它只负责：
&lt;ul>
&lt;li>&lt;strong>展示：&lt;/strong> 根据 Controller 提供的数据渲染 UI。&lt;/li>
&lt;li>&lt;strong>交互：&lt;/strong> 检测用户操作（如点击、滑动、输入）并将这些事件 &lt;strong>传递&lt;/strong> 给 Controller 处理。View 本身不决定如何处理这些事件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>可复用：&lt;/strong> 设计良好的 View 组件（如自定义的 &lt;code>UIView&lt;/code> 子类）可以在不同的界面甚至不同的项目中复用。&lt;/li>
&lt;li>&lt;strong>独立于 Model：&lt;/strong> View 不应该直接访问或操作 Model。它应该通过 Controller 来获取展示所需的数据（通常是简单的、格式化的数据，而不是整个 Model 对象）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="controller-控制器">&lt;strong>Controller (控制器)&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>职责：&lt;/strong> 作为 &lt;strong>Model&lt;/strong> 和 &lt;strong>View&lt;/strong> 之间的 &lt;strong>协调者 (Mediator)&lt;/strong> 和 &lt;strong>胶水 (Glue)&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>包含什么：&lt;/strong> 在 iOS 中，最主要的 Controller 是 &lt;code>UIViewController&lt;/code> 及其子类。&lt;/li>
&lt;li>&lt;strong>关键任务：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>管理 View 生命周期：&lt;/strong> 响应 &lt;code>viewDidLoad&lt;/code>, &lt;code>viewWillAppear&lt;/code>, &lt;code>viewDidDisappear&lt;/code> 等事件，负责创建、配置、显示和销毁 View。&lt;/li>
&lt;li>&lt;strong>获取/更新 Model：&lt;/strong> 从数据源（数据库、网络、其他服务）获取数据并填充 Model。响应用户操作或业务逻辑要求更新 Model。&lt;/li>
&lt;li>&lt;strong>更新 View：&lt;/strong> 监听 Model 的变化（通过 KVO、委托、通知等），获取最新的数据，并将其 &lt;strong>格式化&lt;/strong> 后传递给 View 进行显示。&lt;/li>
&lt;li>&lt;strong>处理用户交互：&lt;/strong> 接收来自 View 的用户事件（如按钮点击、表格行选择、文本输入完成），解释这些事件的含义，触发相应的业务逻辑（通常是更新 Model 或导航到其他界面）。&lt;/li>
&lt;li>&lt;strong>导航：&lt;/strong> 管理视图控制器之间的切换（Push/Pop, Present/Dismiss）。&lt;/li>
&lt;li>&lt;strong>处理其他系统事件：&lt;/strong> 如内存警告、旋转事件等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键特性：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>强依赖：&lt;/strong> Controller 通常需要了解具体的 View 和 Model 细节。&lt;/li>
&lt;li>&lt;strong>核心枢纽：&lt;/strong> 大部分应用程序逻辑（尤其是与UI流程相关的）都汇聚在这里。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="mvc-中的数据流向">&lt;strong>MVC 中的数据流向：&lt;/strong>
&lt;/h4>&lt;p>标准的 MVC 数据流有两种主要路径：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户交互路径：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用户在 &lt;strong>View&lt;/strong> 上操作（点击按钮）。&lt;/li>
&lt;li>&lt;strong>View&lt;/strong> 将事件 &lt;strong>通知&lt;/strong> 给 &lt;strong>Controller&lt;/strong> (例如：通过 IBAction)。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> &lt;strong>解释&lt;/strong> 事件，执行相应的业务逻辑：
&lt;ul>
&lt;li>可能需要 &lt;strong>更新 Model&lt;/strong> (例如：将商品加入购物车)。&lt;/li>
&lt;li>可能需要 &lt;strong>更新 View&lt;/strong> 状态 (例如：禁用按钮)。&lt;/li>
&lt;li>可能需要 &lt;strong>导航&lt;/strong> 到新界面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果 Model 被更新，Model 会 &lt;strong>通知&lt;/strong> Controller 变化发生了（如果 Controller 监听了 Model）。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> 从 &lt;strong>Model&lt;/strong> 获取 &lt;strong>更新后的数据&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> 将 &lt;strong>格式化后的数据&lt;/strong> &lt;strong>传递给&lt;/strong> &lt;strong>View&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>View&lt;/strong> 根据新数据 &lt;strong>更新其 UI&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Model 变更路径 (非用户直接触发)：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>外部因素导致 &lt;strong>Model&lt;/strong> 发生变化（例如：后台网络请求完成、定时器触发更新）。&lt;/li>
&lt;li>&lt;strong>Model&lt;/strong> &lt;strong>通知&lt;/strong> 其监听者（通常是 &lt;strong>Controller&lt;/strong>）变化发生了。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> 从 &lt;strong>Model&lt;/strong> 获取 &lt;strong>更新后的数据&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>Controller&lt;/strong> 将 &lt;strong>格式化后的数据&lt;/strong> &lt;strong>传递给&lt;/strong> &lt;strong>View&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>View&lt;/strong> 根据新数据 &lt;strong>更新其 UI&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="ios-中的-mvcmassive-view-controller问题">&lt;strong>iOS 中的 MVC（“Massive View Controller”问题）&lt;/strong>
&lt;/h3>&lt;p>&lt;img src="https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250609/l8wN/878X304/image.png"
loading="lazy"
alt="878X304/image.png"
>&lt;/p>
&lt;p>&lt;strong>iOS MVC 的典型问题：Massive View Controller&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Model 与 View 几乎无直接交互&lt;/strong>，完全依赖 &lt;strong>Controller&lt;/strong> 中介。&lt;/li>
&lt;li>&lt;strong>View 与 Controller 强耦合&lt;/strong>：
&lt;ul>
&lt;li>通过 &lt;code>IBOutlet&lt;/code>（视图控件引用）和 &lt;code>IBAction&lt;/code>（事件回调）紧密绑定。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Controller 成为“上帝对象”&lt;/strong>：
&lt;ul>
&lt;li>承担 &lt;strong>业务逻辑&lt;/strong>、&lt;strong>网络请求&lt;/strong>、&lt;strong>数据解析&lt;/strong>、&lt;strong>UI 配置&lt;/strong>、&lt;strong>导航跳转&lt;/strong> 等几乎所有职责。&lt;/li>
&lt;li>导致代码量爆炸（数千行常见），可维护性和可测试性极差。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>💥 &lt;strong>核心问题&lt;/strong>：Controller 违反 &lt;strong>单一职责原则&lt;/strong>，变成“垃圾抽屉”。&lt;/p>&lt;/blockquote>
&lt;h4 id="ios-中的-mvc-uikit-mvc现实与理论的差距">&lt;strong>iOS 中的 MVC (UIKit MVC)：现实与理论的差距&lt;/strong>
&lt;/h4>&lt;p>Apple 在 UIKit 框架中推广了 MVC，但其实现方式与经典的 MVC 理论有显著差异，导致了著名的 &lt;strong>“Massive View Controller” (臃肿的视图控制器)&lt;/strong> 问题：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">组件&lt;/th>
&lt;th style="text-align: left">经典 MVC 理论职责&lt;/th>
&lt;th style="text-align: left">iOS (UIKit) MVC 实际常见职责&lt;/th>
&lt;th style="text-align: left">导致的问题&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Model&lt;/strong>&lt;/td>
&lt;td style="text-align: left">数据 + 业务逻辑&lt;/td>
&lt;td style="text-align: left">数据 (常为简单结构体/类)，业务逻辑常被放到 Controller 或 Service&lt;/td>
&lt;td style="text-align: left">Model 过于贫血，核心逻辑分散。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>View&lt;/strong>&lt;/td>
&lt;td style="text-align: left">纯展示 + 传递事件&lt;/td>
&lt;td style="text-align: left">展示 + &lt;strong>部分布局逻辑&lt;/strong> (Storyboard/XIB/Code) + 传递事件&lt;/td>
&lt;td style="text-align: left">职责相对清晰，但通过 IBOutlet/IBAction 与 Controller 强耦合。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Controller&lt;/strong>&lt;/td>
&lt;td style="text-align: left">协调 Model 和 View，处理事件&lt;/td>
&lt;td style="text-align: left">&lt;strong>几乎包含所有非 Model/View 的代码&lt;/strong>：&lt;br>- 业务逻辑&lt;br>- 网络请求&lt;br>- 数据解析&lt;br>- 数据转换/格式化&lt;br>- View 配置/布局 (常大量)&lt;br>- 导航逻辑&lt;br>- 处理 Model 变更&lt;br>- 处理用户事件&lt;br>- 生命周期管理&lt;br>- 依赖管理&lt;/td>
&lt;td style="text-align: left">&lt;strong>Massive View Controller!&lt;/strong> &lt;br>代码量巨大，难以维护、测试、复用。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="为什么-ios-mvc-容易导致-massive-view-controller">&lt;strong>为什么 iOS MVC 容易导致 Massive View Controller？&lt;/strong>
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>&lt;code>UIViewController&lt;/code> 的天然定位：&lt;/strong> Apple 设计 &lt;code>UIViewController&lt;/code> 时，就让它紧密关联着一个 &lt;code>UIView&lt;/code> (&lt;code>self.view&lt;/code>)，并且负责其生命周期。这使得 Controller 和 View 的界限在代码中变得模糊，开发者很容易把 View 的配置代码（本应属于 View 的职责）直接写在 Controller 里。&lt;/li>
&lt;li>&lt;strong>Storyboard/XIB 的便利与陷阱：&lt;/strong> Interface Builder (Storyboard/XIB) 虽然能可视化设计 UI，但它将 View 的布局和部分配置（如 Auto Layout 约束）以序列化形式存储。Controller 需要通过 &lt;code>IBOutlet&lt;/code> 连接到这些 View 元素进行动态操作。这种强连接鼓励了在 Controller 中直接操作 View 细节。&lt;/li>
&lt;li>&lt;strong>事件处理 (IBAction)：&lt;/strong> &lt;code>IBAction&lt;/code> 方法直接定义在 Controller 中，处理用户交互的逻辑自然就写在了 Controller 里。&lt;/li>
&lt;li>&lt;strong>缺少明确的中间层：&lt;/strong> 经典的 MVC 中，Controller 应该是薄薄的一层协调者。但在 iOS 实践中，由于没有强制分离的规则，业务逻辑、数据转换、网络交互等本可以独立出来的逻辑，都因为方便而被塞进了 Controller。&lt;/li>
&lt;li>&lt;strong>Model 的“贫血”：&lt;/strong> 很多 iOS 开发者习惯将 Model 设计为仅包含数据的简单结构（贫血模型），而将操作这些数据的业务逻辑放在 Controller 中，进一步加重了 Controller 的负担。&lt;/li>
&lt;/ol>
&lt;h4 id="ios-mvc-的优点">&lt;strong>iOS MVC 的优点：&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>简单直观：&lt;/strong> 概念清晰，上手容易，尤其适合小型项目或原型开发。&lt;/li>
&lt;li>&lt;strong>Apple 官方支持：&lt;/strong> UIKit 框架本身的设计就是围绕 MVC 构建的，有大量的文档、教程和示例代码。&lt;/li>
&lt;li>&lt;strong>工具集成：&lt;/strong> Storyboard/XIB 与 &lt;code>UIViewController&lt;/code> 的集成非常紧密。&lt;/li>
&lt;li>&lt;strong>生命周期管理：&lt;/strong> &lt;code>UIViewController&lt;/code> 提供了明确的视图生命周期钩子。&lt;/li>
&lt;/ul>
&lt;h4 id="ios-mvc-的缺点">&lt;strong>iOS MVC 的缺点：&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>Massive View Controller：&lt;/strong> 这是最核心的痛点，导致代码臃肿、难以阅读、维护困难、复用性差。&lt;/li>
&lt;li>&lt;strong>难以单元测试：&lt;/strong> Controller 通常依赖 &lt;code>UIKit&lt;/code> 组件（如 &lt;code>UIView&lt;/code>, &lt;code>UIViewController&lt;/code> 生命周期）、网络请求、数据库等，使得对其进行隔离单元测试变得复杂且脆弱。庞大的 Controller 也意味着测试用例会非常庞大。&lt;/li>
&lt;li>&lt;strong>紧耦合：&lt;/strong> View 和 Controller 通过 &lt;code>IBOutlet&lt;/code>/&lt;code>IBAction&lt;/code> 紧密耦合，难以独立复用或替换。Controller 通常也直接知晓具体的 Model 和 View 细节。&lt;/li>
&lt;li>&lt;strong>职责模糊：&lt;/strong> 业务逻辑、数据转换、UI 更新逻辑混杂在 Controller 中，违反了单一职责原则。&lt;/li>
&lt;li>&lt;strong>代码复用性差：&lt;/strong> 与特定 View 强关联的逻辑很难在其他地方复用。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="改进-mvc-的方案减轻-controller-负担">&lt;strong>改进 MVC 的方案（减轻 Controller 负担）&lt;/strong>
&lt;/h3>&lt;p>&lt;img src="https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250609/Q8S8/792X496/image.png"
loading="lazy"
alt="792X496/image.png"
>&lt;/p>
&lt;p>&lt;strong>缓解 Massive View Controller 的实践&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>抽取独立组件&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>Service 层&lt;/strong>：封装网络请求、数据库操作。&lt;/li>
&lt;li>&lt;strong>DataSource 对象&lt;/strong>：处理 &lt;code>UITableView&lt;/code>/&lt;code>UICollectionView&lt;/code> 的数据源逻辑。&lt;/li>
&lt;li>&lt;strong>Utils 工具类&lt;/strong>：提供格式化、校验等辅助函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Controller 仅保留核心协调职责&lt;/strong>：
&lt;ul>
&lt;li>初始化组件、响应生命周期事件、高层导航决策。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Model 升级为“富模型”&lt;/strong>：
&lt;ul>
&lt;li>包含业务逻辑（如 &lt;code>User.validatePassword()&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>View 封装自定义控件&lt;/strong>：
&lt;ul>
&lt;li>将布局代码移入 &lt;code>UIView&lt;/code> 子类，减少 Controller 内 UI 代码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>✅ &lt;strong>效果&lt;/strong>：Controller 瘦身，代码可读性和可测试性提升。&lt;/p>&lt;/blockquote>
&lt;h4 id="如何缓解-massive-view-controller-在-mvc-框架内">&lt;strong>如何缓解 Massive View Controller？ (在 MVC 框架内)&lt;/strong>
&lt;/h4>&lt;p>即使坚持使用 MVC，也可以通过一些实践来减轻 Controller 的负担：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>富 Model (Rich Model)：&lt;/strong> 将业务逻辑尽可能地移动到 Model 中。让 Model 不仅仅是一个数据结构，而是包含操作这些数据的方法。例如，&lt;code>User&lt;/code> 模型可以有 &lt;code>changePassword&lt;/code> 方法，内部处理验证逻辑。&lt;/li>
&lt;li>&lt;strong>数据源和委托分离：&lt;/strong> 对于 &lt;code>UITableView&lt;/code> 或 &lt;code>UICollectionView&lt;/code>，将其 &lt;code>dataSource&lt;/code> 和 &lt;code>delegate&lt;/code> 分离到独立的类中（例如 &lt;code>MyTableDataSource&lt;/code>），而不是让 Controller 直接实现所有协议方法。&lt;/li>
&lt;li>&lt;strong>创建 Helper/Utility 类：&lt;/strong> 将通用的工具方法、格式化逻辑、网络请求封装等提取到独立的 Helper 或 Service 类中。&lt;/li>
&lt;li>&lt;strong>使用 Child View Controllers：&lt;/strong> 将复杂界面拆分成多个逻辑区域，每个区域由自己的 Child View Controller 管理，父 Controller 负责协调。&lt;/li>
&lt;li>&lt;strong>避免在 Controller 中做复杂的 View 布局：&lt;/strong> 尽量使用 Auto Layout（在 Interface Builder 或代码中），并将自定义 View 的布局逻辑封装在 &lt;code>UIView&lt;/code> 子类中。Controller 只负责提供数据和处理高层事件。&lt;/li>
&lt;li>&lt;strong>谨慎使用 Storyboard Segues：&lt;/strong> 避免在 Segue 的 &lt;code>prepareForSegue&lt;/code> 方法中塞入过多的数据准备和逻辑。考虑使用更明确的导航方法或路由机制。&lt;/li>
&lt;li>&lt;strong>利用扩展 (Extensions)：&lt;/strong> 将 Controller 中不同职责的代码划分到不同的扩展文件中（例如 &lt;code>MyViewController+Network.swift&lt;/code>, &lt;code>MyViewController+TableView.swift&lt;/code>），提高可读性，但逻辑上还在同一个类里。&lt;/li>
&lt;/ol>
&lt;h4 id="mvc-的替代方案">&lt;strong>MVC 的替代方案：&lt;/strong>
&lt;/h4>&lt;p>为了解决 MVC 在 iOS 中固有的问题，出现了多种替代架构模式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MVVM (Model-View-ViewModel)：&lt;/strong> 引入 ViewModel 层，负责将 Model 数据转换为 View 可直接显示的数据，并包含视图相关的状态和命令。View 和 ViewModel 通过数据绑定（如 Combine, RxSwift）连接，大大减少了 Controller（或 View，在 SwiftUI 中）的职责。&lt;strong>这是目前最流行的替代方案，尤其适合 SwiftUI。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>VIPER (View-Interactor-Presenter-Entity-Router)：&lt;/strong> 将职责划分得更加细致（路由、业务逻辑、展示逻辑、实体），每个组件职责单一且明确，可测试性极高。但引入的复杂性和文件数量也显著增加，适合大型、长期维护的项目。&lt;/li>
&lt;li>&lt;strong>MVP (Model-View-Presenter)：&lt;/strong> 类似于 MVVM，但 View 和 Presenter 之间通常通过接口/协议进行通信，强调被动 View。在 iOS 中不如 MVVM 流行。&lt;/li>
&lt;li>&lt;strong>Clean Architecture / TCA (The Composable Architecture)：&lt;/strong> 强调分层（Entities, Use Cases, Interface Adapters, Frameworks &amp;amp; Drivers）、依赖规则（依赖向内指向核心业务逻辑）、单向数据流。TCA 是基于 Swift 的一个具体实现，结合了 Elm 和 Redux 的思想，提供强大的状态管理和可测试性。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="总结">&lt;strong>总结：&lt;/strong>
&lt;/h3>&lt;p>MVC 是一个基础且重要的架构模式，理解其核心思想和在 iOS 中的具体实现（以及由此引发的 Massive View Controller 问题）是 iOS 开发者的必备知识。虽然它在小型项目或简单界面上仍然有效且快速，但在面对复杂应用时，其缺点会变得非常突出。&lt;/p>
&lt;p>&lt;strong>对于新项目：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果主要使用 &lt;strong>SwiftUI&lt;/strong>，MVVM 是非常自然且推荐的选择。&lt;/li>
&lt;li>如果主要使用 &lt;strong>UIKit&lt;/strong>，强烈推荐学习和采用 &lt;strong>MVVM&lt;/strong>（通常结合 Combine 或 RxSwift 进行数据绑定）来避免 Massive View Controller。VIPER 或 Clean Architecture/TCA 是更高级的选择，适用于对可维护性、可测试性要求极高的大型项目。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>对于维护遗留的 UIKit MVC 项目：&lt;/strong> 了解 MVC 的原理和问题所在，并逐步应用上述的“缓解策略”进行重构，或者在有条件和收益的情况下，逐步向 MVVM 等模式迁移部分功能模块。&lt;/p></description></item><item><title>博客框架 Hugo，Hexo，Jekyll 三者的区别和对比</title><link>https://muo123.github.io/articles/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6-hugohexojekyll-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 02 Jun 2025 23:23:47 +0800</pubDate><guid>https://muo123.github.io/articles/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6-hugohexojekyll-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AF%B9%E6%AF%94/</guid><description>&lt;img src="https://tc.z.wiki/autoupload/20250603/5th1/848X557/image.png" alt="Featured image of post 博客框架 Hugo，Hexo，Jekyll 三者的区别和对比" />&lt;p>以下是 Hugo、Hexo 和 Jekyll 三大主流静态博客框架的详细对比，从核心特性到适用场景的全方位分析，帮助你快速选择最适合的工具：&lt;/p>
&lt;hr>
&lt;h3 id="核心区别对比表">&lt;strong>核心区别对比表&lt;/strong>
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>特性&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Hugo&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Hexo&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Jekyll&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>开发语言&lt;/strong>&lt;/td>
&lt;td>Go（单二进制文件）&lt;/td>
&lt;td>Node.js&lt;/td>
&lt;td>Ruby&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>构建速度&lt;/strong>&lt;/td>
&lt;td>⚡ &lt;strong>极快&lt;/strong>（千页秒级）&lt;/td>
&lt;td>🚀 快（依赖插件复杂度）&lt;/td>
&lt;td>⏳ 较慢（大型项目可能需分钟级）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>GitHub Pages 支持&lt;/strong>&lt;/td>
&lt;td>❌ 需本地构建后推送产物&lt;/td>
&lt;td>❌ 需本地构建后推送产物&lt;/td>
&lt;td>✅ &lt;strong>原生支持&lt;/strong>（自动构建）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>安装复杂度&lt;/strong>&lt;/td>
&lt;td>★☆☆（无需环境，下载即用）&lt;/td>
&lt;td>★★☆（需 Node.js 环境）&lt;/td>
&lt;td>★★★（需 Ruby 环境及 Bundler）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>主题生态&lt;/strong>&lt;/td>
&lt;td>丰富（&lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>Hugo Themes&lt;/a>）&lt;/td>
&lt;td>极丰富（&lt;a class="link" href="https://hexo.io/themes/" target="_blank" rel="noopener"
>Hexo Themes&lt;/a>）&lt;/td>
&lt;td>成熟（&lt;a class="link" href="https://jekyllthemes.io/" target="_blank" rel="noopener"
>Jekyll Themes&lt;/a>）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>插件扩展性&lt;/strong>&lt;/td>
&lt;td>中等（内置短代码/部分插件）&lt;/td>
&lt;td>✅ &lt;strong>极强&lt;/strong>（600+ 插件）&lt;/td>
&lt;td>良好（Gem 插件）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>模板引擎&lt;/strong>&lt;/td>
&lt;td>Go Templates（学习曲线陡）&lt;/td>
&lt;td>EJS/Swig/Pug（灵活）&lt;/td>
&lt;td>Liquid（易上手）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>内容管理&lt;/strong>&lt;/td>
&lt;td>灵活（支持自定义内容类型）&lt;/td>
&lt;td>标准 Markdown + Front Matter&lt;/td>
&lt;td>标准 Markdown + Front Matter&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>适用人群&lt;/strong>&lt;/td>
&lt;td>大型站点/效率优先者&lt;/td>
&lt;td>前端开发者/插件爱好者&lt;/td>
&lt;td>GitHub 新手/讨厌本地构建者&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="深度解析三大框架">&lt;strong>深度解析三大框架&lt;/strong>
&lt;/h3>&lt;h4 id="1-hugo速度至上的极简主义">1. &lt;strong>Hugo：速度至上的极简主义&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>优势&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>无需依赖环境&lt;/strong>：单文件执行，解压即用，跨平台无兼容问题。&lt;/li>
&lt;li>&lt;strong>极致构建速度&lt;/strong>：千篇文章构建仅需 2-5 秒，适合频繁更新的大型博客。&lt;/li>
&lt;li>&lt;strong>强类型内容模型&lt;/strong>：可自定义内容结构（如技术文档、作品集）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>劣势&lt;/strong>
&lt;ul>
&lt;li>Go Templates 语法较复杂（例如条件判断需写 &lt;code>{{ if eq .A .B }}&lt;/code>）。&lt;/li>
&lt;li>插件生态弱于 Hexo，高级功能需手动开发。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>典型用户&lt;/strong>：技术博主、文档站点维护者、讨厌等待构建的人。&lt;/li>
&lt;/ul>
&lt;h4 id="2-hexo前端开发者的瑞士军刀">2. &lt;strong>Hexo：前端开发者的瑞士军刀&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>优势&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>插件驱动&lt;/strong>：支持图床优化（&lt;code>hexo-asset-image&lt;/code>）、SEO 增强（&lt;code>hexo-seo&lt;/code>）等深度定制。&lt;/li>
&lt;li>&lt;strong>技术栈亲和&lt;/strong>：基于 Node.js，前端开发者可无缝接入 Webpack/Babel 等工具。&lt;/li>
&lt;li>&lt;strong>主题高度自由&lt;/strong>：可修改主题源码，自由度远超 Hugo/Jekyll 的主题配置。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>劣势&lt;/strong>
&lt;ul>
&lt;li>插件过多可能导致构建缓慢（需谨慎选择插件）。&lt;/li>
&lt;li>需熟悉 Node.js 开发环境（版本兼容问题常见）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>典型用户&lt;/strong>：前端工程师、需要深度定制的技术博主。&lt;/li>
&lt;/ul>
&lt;h4 id="3-jekyllgithub-亲儿子的零配置方案">3. &lt;strong>Jekyll：GitHub 亲儿子的零配置方案&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>优势&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>无缝 GitHub 集成&lt;/strong>：推送 Markdown 即自动发布，无需本地构建。&lt;/li>
&lt;li>&lt;strong>低学习曲线&lt;/strong>：Liquid 模板类似自然语言（例：&lt;code>{% if page.title %}&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>官方维护保障&lt;/strong>：GitHub 官方支持，兼容性无忧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>劣势&lt;/strong>
&lt;ul>
&lt;li>Ruby 环境在 Windows 易出错（需 RubyInstaller + DevKit）。&lt;/li>
&lt;li>百篇文章以上构建显著变慢（&amp;gt;30秒）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>典型用户&lt;/strong>：写作优先的博主、非技术背景用户、小型项目快速上线。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="关键决策场景">&lt;strong>关键决策场景&lt;/strong>
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>你的需求&lt;/strong>&lt;/th>
&lt;th>&lt;strong>推荐框架&lt;/strong>&lt;/th>
&lt;th>&lt;strong>原因&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>纯写作/讨厌命令行&lt;/td>
&lt;td>Jekyll&lt;/td>
&lt;td>推送 Markdown 即发布，无需构建&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>博客规模大（&amp;gt;500篇文章）&lt;/td>
&lt;td>Hugo&lt;/td>
&lt;td>构建速度碾压对手，节省生命&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>前端开发者/爱折腾插件&lt;/td>
&lt;td>Hexo&lt;/td>
&lt;td>用 Node.js 生态定制功能（如 PWA 支持）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>需托管 GitHub 且追求稳定&lt;/td>
&lt;td>Jekyll&lt;/td>
&lt;td>官方支持，无构建失败风险&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>多语言站点（i18n）&lt;/td>
&lt;td>Hugo&lt;/td>
&lt;td>内置多语言支持，配置简单&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="终极选择建议">&lt;strong>终极选择建议&lt;/strong>
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>选 Hugo 如果&lt;/strong>：你追求效率至上，内容量巨大，或抗拒环境配置。&lt;/li>
&lt;li>&lt;strong>选 Hexo 如果&lt;/strong>：你是前端开发者，需要插件拓展功能（如 Algolia 搜索）。&lt;/li>
&lt;li>&lt;strong>选 Jekyll 如果&lt;/strong>：你希望完全依赖 GitHub 自动化，专注写作而非技术。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>💡 &lt;strong>部署提示&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>Hugo/Hexo 可用 GitHub Actions 自动化构建（&lt;a class="link" href="https://github.com/peaceiris/actions-hugo" target="_blank" rel="noopener"
>示例脚本&lt;/a>）。&lt;/li>
&lt;li>避免将 &lt;code>node_modules&lt;/code>/&lt;code>public&lt;/code> 推送到 Git 仓库（用 &lt;code>.gitignore&lt;/code> 过滤）。&lt;/li>
&lt;/ul>&lt;/blockquote></description></item><item><title>Github Pages 搭建个人博客可供选择的框架有哪些</title><link>https://muo123.github.io/articles/github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B/</link><pubDate>Mon, 02 Jun 2025 22:52:19 +0800</pubDate><guid>https://muo123.github.io/articles/github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B/</guid><description>&lt;img src="https://tc.z.wiki/autoupload/20250603/sjGQ/1085X637/image.png" alt="Featured image of post Github Pages 搭建个人博客可供选择的框架有哪些" />&lt;p>在 GitHub Pages 上搭建个人博客是极佳的选择（免费、稳定、易用），而选择合适的静态网站生成框架至关重要。以下是主流且与 GitHub Pages 配合良好的框架，以及它们之间的核心区别：&lt;/p>
&lt;h2 id="-主流框架推荐">🎈 主流框架推荐
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>Jekyll&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>官方支持：&lt;/strong> GitHub Pages &lt;strong>原生支持&lt;/strong> Jekyll。这意味着你只需将 Jekyll 源文件推送到仓库，GitHub 会自动为你构建网站。无需本地构建或上传 &lt;code>_site&lt;/code> 目录。&lt;/li>
&lt;li>&lt;strong>语言：&lt;/strong> Ruby&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>简单易上手：&lt;/strong> 主题、插件丰富，文档完善，社区庞大，非常适合初学者。&lt;/li>
&lt;li>&lt;strong>约定优于配置：&lt;/strong> 遵循特定目录结构，很多功能开箱即用。&lt;/li>
&lt;li>&lt;strong>Liquid 模板引擎：&lt;/strong> 灵活但学习曲线相对平缓。&lt;/li>
&lt;li>&lt;strong>Markdown 支持：&lt;/strong> 内置支持，方便写作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优势：&lt;/strong> 与 GitHub Pages 集成最无缝，部署最省心。&lt;/li>
&lt;li>&lt;strong>劣势：&lt;/strong> 构建速度在大型站点上相对较慢；需要 Ruby 环境进行本地开发。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hugo&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>官方支持：&lt;/strong> GitHub Pages &lt;strong>不原生支持&lt;/strong> Hugo。你需要&lt;strong>在本地构建&lt;/strong>网站（生成 &lt;code>public&lt;/code> 目录），然后将这个 &lt;code>public&lt;/code> 目录的内容推送到 GitHub 仓库（通常是 &lt;code>gh-pages&lt;/code> 分支或特定分支/docs 目录）。&lt;/li>
&lt;li>&lt;strong>语言：&lt;/strong> Go (编译成单个二进制文件)&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>极速构建：&lt;/strong> 最大的优势！构建成千上万页面也只需几秒到十几秒。&lt;/li>
&lt;li>&lt;strong>单二进制文件：&lt;/strong> 安装部署极其简单，无需复杂的语言环境。&lt;/li>
&lt;li>&lt;strong>强大灵活：&lt;/strong> 内容组织方式灵活，模板功能强大（Go Templates）。&lt;/li>
&lt;li>&lt;strong>主题丰富：&lt;/strong> 拥有非常庞大且活跃的主题生态系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优势：&lt;/strong> 无与伦比的构建速度，本地开发体验极佳，部署简单（虽然需要本地构建）。&lt;/li>
&lt;li>&lt;strong>劣势：&lt;/strong> Go Templates 学习曲线可能比 Liquid 稍陡；需要手动构建后部署到 GitHub Pages。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Hexo&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>官方支持：&lt;/strong> GitHub Pages &lt;strong>不原生支持&lt;/strong> Hexo。需要&lt;strong>本地构建&lt;/strong>（生成 &lt;code>public&lt;/code> 目录），然后推送 &lt;code>public&lt;/code> 目录内容。&lt;/li>
&lt;li>&lt;strong>语言：&lt;/strong> Node.js&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>快速高效：&lt;/strong> 构建速度较快（虽然通常不及 Hugo）。&lt;/li>
&lt;li>&lt;strong>插件驱动：&lt;/strong> 拥有海量的插件，功能扩展性极强。&lt;/li>
&lt;li>&lt;strong>主题丰富：&lt;/strong> 主题数量众多，风格多样。&lt;/li>
&lt;li>&lt;strong>面向博客优化：&lt;/strong> 对博客所需的标签、分类、归档等支持良好。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优势：&lt;/strong> 基于 Node.js，对前端开发者友好；插件生态强大，可定制性高。&lt;/li>
&lt;li>&lt;strong>劣势：&lt;/strong> 需要 Node.js 环境；配置可能相对复杂一些。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>VuePress / VitePress&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>官方支持：&lt;/strong> GitHub Pages &lt;strong>不原生支持&lt;/strong>。需要&lt;strong>本地构建&lt;/strong>，推送构建产物（通常是 &lt;code>.vuepress/dist&lt;/code> 或 &lt;code>.vitepress/dist&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>语言：&lt;/strong> Node.js (基于 Vue.js)&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>技术栈驱动：&lt;/strong> 专为技术文档设计，但对博客也非常适合，尤其适合熟悉 Vue.js 的开发者。&lt;/li>
&lt;li>&lt;strong>Markdown 扩展强大：&lt;/strong> 可以在 Markdown 中直接使用 Vue 组件，实现高度交互性。&lt;/li>
&lt;li>&lt;strong>默认主题优秀：&lt;/strong> 官方默认主题简洁美观，功能实用。&lt;/li>
&lt;li>&lt;strong>开发体验好：&lt;/strong> 基于 Vite，启动和热更新速度极快。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优势：&lt;/strong> 技术文档和博客的完美结合；利用 Vue 组件系统实现高度定制；优秀的开发体验。&lt;/li>
&lt;li>&lt;strong>劣势：&lt;/strong> 对不熟悉 Vue 的开发者有一定门槛；主题和插件生态相对 Jekyll/Hugo/Hexo 规模小些（但增长快）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Eleventy (11ty)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>官方支持：&lt;/strong> GitHub Pages &lt;strong>不原生支持&lt;/strong>。需要&lt;strong>本地构建&lt;/strong>，推送构建产物（可配置）。&lt;/li>
&lt;li>&lt;strong>语言：&lt;/strong> Node.js&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>极度灵活与简单：&lt;/strong> 零配置默认值，但可深度定制。支持多种模板语言（Liquid, Nunjucks, Handlebars, Markdown, HTML 等），你可以混用。&lt;/li>
&lt;li>&lt;strong>轻量级：&lt;/strong> 框架本身非常精简，概念少。&lt;/li>
&lt;li>&lt;strong>高性能：&lt;/strong> 构建速度很快。&lt;/li>
&lt;li>&lt;strong>“无框架”框架：&lt;/strong> 更倾向于提供核心的静态生成能力，不强制特定的项目结构或数据模型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优势：&lt;/strong> 极高的灵活性和自由度；学习曲线相对平缓（尤其如果你熟悉其中一种模板语言）；性能优异。&lt;/li>
&lt;li>&lt;strong>劣势：&lt;/strong> 需要自己搭建更多东西（相比开箱即用的框架）；主题生态不如前几个成熟；需要 Node.js 环境。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Astro&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>官方支持：&lt;/strong> GitHub Pages &lt;strong>不原生支持&lt;/strong>。需要&lt;strong>本地构建&lt;/strong>，推送构建产物（&lt;code>dist&lt;/code> 目录）。&lt;/li>
&lt;li>&lt;strong>语言：&lt;/strong> Node.js (但组件理念独特)&lt;/li>
&lt;li>&lt;strong>特点：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>岛屿架构：&lt;/strong> 核心理念！默认输出纯静态 HTML/CSS，但可以按需“激活”页面上的交互式组件（称为“岛屿”），大幅减少不必要的 JS。&lt;/li>
&lt;li>&lt;strong>框架无关：&lt;/strong> 可以在 &lt;code>.astro&lt;/code> 组件中无缝使用 React, Vue, Svelte, Solid 等 UI 框架的组件。&lt;/li>
&lt;li>&lt;strong>高性能：&lt;/strong> 非常注重输出站点的性能（速度、SEO）。&lt;/li>
&lt;li>&lt;strong>内容优先：&lt;/strong> 对 Markdown/MDX 支持优秀，内置内容集合功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优势：&lt;/strong> 构建现代、高性能网站的最佳选择之一；独特的架构带来极佳的用户体验；强大的内容管理能力；灵活的组件系统。&lt;/li>
&lt;li>&lt;strong>劣势：&lt;/strong> 概念较新，学习曲线相对陡峭；需要 Node.js 环境；生态还在快速发展中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="-核心区别对比表">🔍 核心区别对比表
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">特性&lt;/th>
&lt;th style="text-align: left">Jekyll&lt;/th>
&lt;th style="text-align: left">Hugo&lt;/th>
&lt;th style="text-align: left">Hexo&lt;/th>
&lt;th style="text-align: left">VuePress/VitePress&lt;/th>
&lt;th style="text-align: left">Eleventy (11ty)&lt;/th>
&lt;th style="text-align: left">Astro&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>原生 GitHub Pages 支持&lt;/strong>&lt;/td>
&lt;td style="text-align: left">✅ &lt;strong>是&lt;/strong> (自动构建)&lt;/td>
&lt;td style="text-align: left">❌ 否 (需本地构建)&lt;/td>
&lt;td style="text-align: left">❌ 否 (需本地构建)&lt;/td>
&lt;td style="text-align: left">❌ 否 (需本地构建)&lt;/td>
&lt;td style="text-align: left">❌ 否 (需本地构建)&lt;/td>
&lt;td style="text-align: left">❌ 否 (需本地构建)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>开发语言&lt;/strong>&lt;/td>
&lt;td style="text-align: left">Ruby&lt;/td>
&lt;td style="text-align: left">Go (单二进制)&lt;/td>
&lt;td style="text-align: left">Node.js&lt;/td>
&lt;td style="text-align: left">Node.js (Vue)&lt;/td>
&lt;td style="text-align: left">Node.js&lt;/td>
&lt;td style="text-align: left">Node.js&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>最大优势&lt;/strong>&lt;/td>
&lt;td style="text-align: left">与 GitHub Pages 集成&lt;/td>
&lt;td style="text-align: left">&lt;strong>极速构建&lt;/strong>&lt;/td>
&lt;td style="text-align: left">插件生态强大&lt;/td>
&lt;td style="text-align: left">Markdown+Vue组件&lt;/td>
&lt;td style="text-align: left">&lt;strong>灵活简单&lt;/strong>，多模板&lt;/td>
&lt;td style="text-align: left">&lt;strong>岛屿架构&lt;/strong>，高性能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>构建速度&lt;/strong>&lt;/td>
&lt;td style="text-align: left">较慢 (大型站点)&lt;/td>
&lt;td style="text-align: left">⚡ &lt;strong>极快&lt;/strong>&lt;/td>
&lt;td style="text-align: left">快&lt;/td>
&lt;td style="text-align: left">快 (VitePress 更快)&lt;/td>
&lt;td style="text-align: left">快&lt;/td>
&lt;td style="text-align: left">快&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>学习曲线&lt;/strong>&lt;/td>
&lt;td style="text-align: left">平缓&lt;/td>
&lt;td style="text-align: left">中等 (Go模板)&lt;/td>
&lt;td style="text-align: left">中等&lt;/td>
&lt;td style="text-align: left">中等 (需Vue基础)&lt;/td>
&lt;td style="text-align: left">平缓 (熟悉模板即可)&lt;/td>
&lt;td style="text-align: left">较陡 (新概念)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>主题生态&lt;/strong>&lt;/td>
&lt;td style="text-align: left">非常丰富&lt;/td>
&lt;td style="text-align: left">非常丰富&lt;/td>
&lt;td style="text-align: left">非常丰富&lt;/td>
&lt;td style="text-align: left">良好 (官方主题优秀)&lt;/td>
&lt;td style="text-align: left">增长中&lt;/td>
&lt;td style="text-align: left">增长迅速&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>插件/扩展性&lt;/strong>&lt;/td>
&lt;td style="text-align: left">良好&lt;/td>
&lt;td style="text-align: left">良好 (短代码等)&lt;/td>
&lt;td style="text-align: left">✅ &lt;strong>极好&lt;/strong>&lt;/td>
&lt;td style="text-align: left">良好&lt;/td>
&lt;td style="text-align: left">良好 (通过配置/JS)&lt;/td>
&lt;td style="text-align: left">良好 (集成框架能力强)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>灵活性/自由度&lt;/strong>&lt;/td>
&lt;td style="text-align: left">中等&lt;/td>
&lt;td style="text-align: left">高&lt;/td>
&lt;td style="text-align: left">高&lt;/td>
&lt;td style="text-align: left">高 (Vue组件)&lt;/td>
&lt;td style="text-align: left">✅ &lt;strong>极高&lt;/strong>&lt;/td>
&lt;td style="text-align: left">高&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>最适合人群&lt;/strong>&lt;/td>
&lt;td style="text-align: left">新手/GitHub集成优先&lt;/td>
&lt;td style="text-align: left">讨厌等待/大型站点&lt;/td>
&lt;td style="text-align: left">前端开发者/插件爱好者&lt;/td>
&lt;td style="text-align: left">Vue开发者/技术文档&lt;/td>
&lt;td style="text-align: left">追求简洁自由/多语言者&lt;/td>
&lt;td style="text-align: left">性能控/现代框架使用者&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="-选择建议">📌 选择建议
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>追求最简单部署，不想本地构建：选 &lt;code>Jekyll&lt;/code>。&lt;/strong> GitHub 替你搞定一切，专注于写作。&lt;/li>
&lt;li>&lt;strong>博客规模大或无法忍受慢速构建：选 &lt;code>Hugo&lt;/code>。&lt;/strong> 速度是王道，部署步骤也简单。&lt;/li>
&lt;li>&lt;strong>前端开发者，喜欢丰富的插件和主题：选 &lt;code>Hexo&lt;/code>。&lt;/strong> Node.js 环境很熟悉，扩展性强。&lt;/li>
&lt;li>&lt;strong>熟悉 Vue.js 或需要强交互/技术文档：选 &lt;code>VuePress&lt;/code> / &lt;code>VitePress&lt;/code>。&lt;/strong> Markdown + Vue 的组合非常强大，开发体验好。&lt;/li>
&lt;li>&lt;strong>喜欢简洁、灵活、自由度高，不依赖特定框架：选 &lt;code>Eleventy&lt;/code>。&lt;/strong> 用你喜欢的模板语言，按你的方式组织。&lt;/li>
&lt;li>&lt;strong>构建高性能、现代化网站，想用不同框架组件：选 &lt;code>Astro&lt;/code>。&lt;/strong> 岛屿架构带来卓越性能，未来感十足。&lt;/li>
&lt;/ul>
&lt;h2 id="-重要提示">💡 重要提示
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>部署方式：&lt;/strong> 只有 Jekyll 享受 GitHub Pages 的原生构建支持。对于其他框架，你&lt;strong>必须&lt;/strong>在本地或通过 GitHub Actions 等 CI/CD 工具完成构建，然后将生成的静态文件（通常是 &lt;code>public&lt;/code>, &lt;code>dist&lt;/code>, &lt;code>_site&lt;/code>, &lt;code>docs&lt;/code> 等目录）推送到仓库的特定分支（如 &lt;code>gh-pages&lt;/code>）或主分支的特定目录（如 &lt;code>/docs&lt;/code>），并在仓库设置中指定源。&lt;/li>
&lt;li>&lt;strong>GitHub Actions：&lt;/strong> 对于非 Jekyll 框架，强烈推荐使用 GitHub Actions 自动化构建和部署过程。这样你只需推送源代码，Actions 会自动执行构建并将生成的静态文件部署到 GitHub Pages。官方或社区通常提供现成的 Action 工作流。&lt;/li>
&lt;li>&lt;strong>考虑熟悉度：&lt;/strong> 选择你或你的团队最熟悉的语言和技术的框架，会大大降低学习成本和开发效率。&lt;/li>
&lt;li>&lt;strong>需求驱动：&lt;/strong> 明确你的博客需求（纯写作？需要复杂功能？需要极致性能？需要特定技术栈集成？），再根据需求选择最匹配的框架。&lt;/li>
&lt;/ol>
&lt;h2 id="-总结">🎯 总结
&lt;/h2>&lt;p>GitHub Pages 为静态博客提供了优秀的托管平台。Jekyll 凭借其原生集成是&lt;strong>最省心&lt;/strong>的选择。Hugo 凭借&lt;strong>无与伦比的构建速度&lt;/strong>是大型站点或追求效率者的首选。Hexo 以其强大的&lt;strong>插件生态&lt;/strong>吸引 Node.js 开发者。VuePress/VitePress 是 &lt;strong>Vue 技术栈和文档需求&lt;/strong>的绝配。Eleventy 提供了&lt;strong>最大的灵活性&lt;/strong>和简洁性。Astro 则代表了&lt;strong>现代高性能 Web 开发&lt;/strong>的方向。&lt;/p>
&lt;p>根据你的具体需求、技术偏好和对部署流程的接受程度，仔细权衡以上框架的特点，就能找到最适合你在 GitHub Pages 上搭建个人博客的工具！开始构建你的博客之旅吧！&lt;/p></description></item></channel></rss>