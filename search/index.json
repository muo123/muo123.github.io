[{"content":"Hugo 没有为 Mermaid 图标提供内置模板，查阅 Hugo 文档发现在 Hugo 中添加 Mermaid 支持可以通过以下步骤实现：\n创建渲染钩子文件 在项目目录中新建文件：\nlayouts/_default/_markup/render-codeblock-mermaid.html\n内容如下：\n1 2 3 4 \u0026lt;pre class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner | htmlEscape | safeHTML }} \u0026lt;/pre\u0026gt; {{ .Page.Store.Set \u0026#34;hasMermaid\u0026#34; true }} 添加 Mermaid 初始化脚本 在 layouts/_default/baseof.html 文件的底部添加（注意需要在\u0026lt;/body\u0026gt;标签之前）：\n1 2 3 4 5 6 {{ if .Store.Get \u0026#34;hasMermaid\u0026#34; }} \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import mermaid from \u0026#39;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs\u0026#39;; mermaid.initialize({ startOnLoad: true }); \u0026lt;/script\u0026gt; {{ end }} 验证使用 创建测试内容 content/post/demo.md：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ```mermaid sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! ``` 实现效果如下所示：\nsequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! 完成以上步骤后，Hugo 站点即可支持 Mermaid 图表渲染。\n","date":"2025-06-10T13:17:52+08:00","image":"https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250610/O17b/1045X478/image.png","permalink":"https://muo123.github.io/p/%E6%80%8E%E4%B9%88%E7%BB%99-hugo-%E6%B7%BB%E5%8A%A0-mermaid/","title":"怎么给 Hugo 添加 Mermaid"},{"content":"本文将深入探讨 MVC (Model-View-Controller) 架构模式，特别是在 iOS开发 中的实现、优缺点和演变。\nMVC 的核心思想：职责分离\nMVC 的核心目标是将应用程序的逻辑划分为三个清晰的角色，每个角色有明确的职责，从而降低代码的耦合度，提高可维护性和可测试性。\n1 2 3 4 5 6 7 8 9 MyFeature/ ├── Model/ │ ├── User.swift // 数据模型 │ └── DataService.swift // 网络/数据库服务 ├── View/ │ ├── ProfileView.swift // 自定义视图 │ └── ProfileCell.swift // TableView单元格 └── Controller/ └── ProfileViewController.swift // 视图控制器 经典 MVC 理论模型 经典 MVC 数据流示意图\n用户 (User) 与 视图 (View) 交互（如点击按钮）。 View 将用户事件传递给 控制器 (Controller)。 Controller 处理逻辑： 更新 模型 (Model) 数据（如保存用户输入）。 从 Model 读取数据（如查询数据库）。 Model 数据变更后通知 Controller（通过观察者模式等）。 Controller 将新数据传递给 View。 View 根据数据更新界面，反馈给用户。 ✅ 理想情况：各层职责分离，数据流清晰。\n❌ iOS 现实：Controller 常过度承担逻辑，导致臃肿。\nModel (模型) 职责： 代表应用程序的核心数据和业务逻辑。 包含什么： 数据结构（例如：User, Product, Order 等类或结构体）。 数据的操作方法（例如：创建、读取、更新、删除 - CRUD）。 业务规则和计算逻辑（例如：验证用户输入、计算订单总价）。 数据持久化操作（例如：与数据库、网络API交互的代码，虽然有时这部分会单独抽象成服务层）。 关键特性： 独立于 UI： Model 完全不关心数据如何显示或用户如何交互。它只关注数据本身和操作数据的逻辑。 通知变更： 当 Model 的数据发生改变时，它需要一种机制来通知相关方（通常是 Controller）。在 iOS 中，这通常通过以下几种方式实现： KVO (Key-Value Observing)： 允许对象监听另一个对象特定属性的变化。（较底层，手动管理麻烦）。 委托模式 (Delegation)： 定义协议，Model 持有对实现了该协议的委托对象（通常是 Controller）的弱引用，并在数据变化时调用委托方法。（常用，但通常是一对一）。 通知中心 (NotificationCenter)： 广播数据变更事件，任何注册监听的组件都可以响应。（一对多，松散耦合，但需注意内存管理和类型安全）。 响应式编程 (Combine/RxSwift)： 使用可观察的流来处理数据变更通知。（现代、强大，但学习曲线较陡）。 直接调用： Controller 在修改 Model 后，直接手动更新 View。（最简单，但耦合度高，容易遗漏）。 View (视图) 职责： 负责数据的可视化呈现和捕获用户的输入事件。 包含什么： UI 组件：UIView 及其子类 (UILabel, UIButton, UITableView, UICollectionView, UITextField 等)。 布局信息：Frame、Auto Layout 约束、Size Classes。 外观样式：颜色、字体、图片、动画效果。 关键特性： 被动： 理想情况下，View 本身不应该包含业务逻辑。它只负责： 展示： 根据 Controller 提供的数据渲染 UI。 交互： 检测用户操作（如点击、滑动、输入）并将这些事件 传递 给 Controller 处理。View 本身不决定如何处理这些事件。 可复用： 设计良好的 View 组件（如自定义的 UIView 子类）可以在不同的界面甚至不同的项目中复用。 独立于 Model： View 不应该直接访问或操作 Model。它应该通过 Controller 来获取展示所需的数据（通常是简单的、格式化的数据，而不是整个 Model 对象）。 Controller (控制器) 职责： 作为 Model 和 View 之间的 协调者 (Mediator) 和 胶水 (Glue)。 包含什么： 在 iOS 中，最主要的 Controller 是 UIViewController 及其子类。 关键任务： 管理 View 生命周期： 响应 viewDidLoad, viewWillAppear, viewDidDisappear 等事件，负责创建、配置、显示和销毁 View。 获取/更新 Model： 从数据源（数据库、网络、其他服务）获取数据并填充 Model。响应用户操作或业务逻辑要求更新 Model。 更新 View： 监听 Model 的变化（通过 KVO、委托、通知等），获取最新的数据，并将其 格式化 后传递给 View 进行显示。 处理用户交互： 接收来自 View 的用户事件（如按钮点击、表格行选择、文本输入完成），解释这些事件的含义，触发相应的业务逻辑（通常是更新 Model 或导航到其他界面）。 导航： 管理视图控制器之间的切换（Push/Pop, Present/Dismiss）。 处理其他系统事件： 如内存警告、旋转事件等。 关键特性： 强依赖： Controller 通常需要了解具体的 View 和 Model 细节。 核心枢纽： 大部分应用程序逻辑（尤其是与UI流程相关的）都汇聚在这里。 MVC 中的数据流向： 标准的 MVC 数据流有两种主要路径：\n用户交互路径：\n用户在 View 上操作（点击按钮）。 View 将事件 通知 给 Controller (例如：通过 IBAction)。 Controller 解释 事件，执行相应的业务逻辑： 可能需要 更新 Model (例如：将商品加入购物车)。 可能需要 更新 View 状态 (例如：禁用按钮)。 可能需要 导航 到新界面。 如果 Model 被更新，Model 会 通知 Controller 变化发生了（如果 Controller 监听了 Model）。 Controller 从 Model 获取 更新后的数据。 Controller 将 格式化后的数据 传递给 View。 View 根据新数据 更新其 UI。 Model 变更路径 (非用户直接触发)：\n外部因素导致 Model 发生变化（例如：后台网络请求完成、定时器触发更新）。 Model 通知 其监听者（通常是 Controller）变化发生了。 Controller 从 Model 获取 更新后的数据。 Controller 将 格式化后的数据 传递给 View。 View 根据新数据 更新其 UI。 iOS 中的 MVC（“Massive View Controller”问题） iOS MVC 的典型问题：Massive View Controller\nModel 与 View 几乎无直接交互，完全依赖 Controller 中介。 View 与 Controller 强耦合： 通过 IBOutlet（视图控件引用）和 IBAction（事件回调）紧密绑定。 Controller 成为“上帝对象”： 承担 业务逻辑、网络请求、数据解析、UI 配置、导航跳转 等几乎所有职责。 导致代码量爆炸（数千行常见），可维护性和可测试性极差。 💥 核心问题：Controller 违反 单一职责原则，变成“垃圾抽屉”。\niOS 中的 MVC (UIKit MVC)：现实与理论的差距 Apple 在 UIKit 框架中推广了 MVC，但其实现方式与经典的 MVC 理论有显著差异，导致了著名的 “Massive View Controller” (臃肿的视图控制器) 问题：\n组件 经典 MVC 理论职责 iOS (UIKit) MVC 实际常见职责 导致的问题 Model 数据 + 业务逻辑 数据 (常为简单结构体/类)，业务逻辑常被放到 Controller 或 Service Model 过于贫血，核心逻辑分散。 View 纯展示 + 传递事件 展示 + 部分布局逻辑 (Storyboard/XIB/Code) + 传递事件 职责相对清晰，但通过 IBOutlet/IBAction 与 Controller 强耦合。 Controller 协调 Model 和 View，处理事件 几乎包含所有非 Model/View 的代码：\n- 业务逻辑\n- 网络请求\n- 数据解析\n- 数据转换/格式化\n- View 配置/布局 (常大量)\n- 导航逻辑\n- 处理 Model 变更\n- 处理用户事件\n- 生命周期管理\n- 依赖管理 Massive View Controller! 代码量巨大，难以维护、测试、复用。 为什么 iOS MVC 容易导致 Massive View Controller？ UIViewController 的天然定位： Apple 设计 UIViewController 时，就让它紧密关联着一个 UIView (self.view)，并且负责其生命周期。这使得 Controller 和 View 的界限在代码中变得模糊，开发者很容易把 View 的配置代码（本应属于 View 的职责）直接写在 Controller 里。 Storyboard/XIB 的便利与陷阱： Interface Builder (Storyboard/XIB) 虽然能可视化设计 UI，但它将 View 的布局和部分配置（如 Auto Layout 约束）以序列化形式存储。Controller 需要通过 IBOutlet 连接到这些 View 元素进行动态操作。这种强连接鼓励了在 Controller 中直接操作 View 细节。 事件处理 (IBAction)： IBAction 方法直接定义在 Controller 中，处理用户交互的逻辑自然就写在了 Controller 里。 缺少明确的中间层： 经典的 MVC 中，Controller 应该是薄薄的一层协调者。但在 iOS 实践中，由于没有强制分离的规则，业务逻辑、数据转换、网络交互等本可以独立出来的逻辑，都因为方便而被塞进了 Controller。 Model 的“贫血”： 很多 iOS 开发者习惯将 Model 设计为仅包含数据的简单结构（贫血模型），而将操作这些数据的业务逻辑放在 Controller 中，进一步加重了 Controller 的负担。 iOS MVC 的优点： 简单直观： 概念清晰，上手容易，尤其适合小型项目或原型开发。 Apple 官方支持： UIKit 框架本身的设计就是围绕 MVC 构建的，有大量的文档、教程和示例代码。 工具集成： Storyboard/XIB 与 UIViewController 的集成非常紧密。 生命周期管理： UIViewController 提供了明确的视图生命周期钩子。 iOS MVC 的缺点： Massive View Controller： 这是最核心的痛点，导致代码臃肿、难以阅读、维护困难、复用性差。 难以单元测试： Controller 通常依赖 UIKit 组件（如 UIView, UIViewController 生命周期）、网络请求、数据库等，使得对其进行隔离单元测试变得复杂且脆弱。庞大的 Controller 也意味着测试用例会非常庞大。 紧耦合： View 和 Controller 通过 IBOutlet/IBAction 紧密耦合，难以独立复用或替换。Controller 通常也直接知晓具体的 Model 和 View 细节。 职责模糊： 业务逻辑、数据转换、UI 更新逻辑混杂在 Controller 中，违反了单一职责原则。 代码复用性差： 与特定 View 强关联的逻辑很难在其他地方复用。 改进 MVC 的方案（减轻 Controller 负担） 缓解 Massive View Controller 的实践\n抽取独立组件： Service 层：封装网络请求、数据库操作。 DataSource 对象：处理 UITableView/UICollectionView 的数据源逻辑。 Utils 工具类：提供格式化、校验等辅助函数。 Controller 仅保留核心协调职责： 初始化组件、响应生命周期事件、高层导航决策。 Model 升级为“富模型”： 包含业务逻辑（如 User.validatePassword()）。 View 封装自定义控件： 将布局代码移入 UIView 子类，减少 Controller 内 UI 代码。 ✅ 效果：Controller 瘦身，代码可读性和可测试性提升。\n如何缓解 Massive View Controller？ (在 MVC 框架内) 即使坚持使用 MVC，也可以通过一些实践来减轻 Controller 的负担：\n富 Model (Rich Model)： 将业务逻辑尽可能地移动到 Model 中。让 Model 不仅仅是一个数据结构，而是包含操作这些数据的方法。例如，User 模型可以有 changePassword 方法，内部处理验证逻辑。 数据源和委托分离： 对于 UITableView 或 UICollectionView，将其 dataSource 和 delegate 分离到独立的类中（例如 MyTableDataSource），而不是让 Controller 直接实现所有协议方法。 创建 Helper/Utility 类： 将通用的工具方法、格式化逻辑、网络请求封装等提取到独立的 Helper 或 Service 类中。 使用 Child View Controllers： 将复杂界面拆分成多个逻辑区域，每个区域由自己的 Child View Controller 管理，父 Controller 负责协调。 避免在 Controller 中做复杂的 View 布局： 尽量使用 Auto Layout（在 Interface Builder 或代码中），并将自定义 View 的布局逻辑封装在 UIView 子类中。Controller 只负责提供数据和处理高层事件。 谨慎使用 Storyboard Segues： 避免在 Segue 的 prepareForSegue 方法中塞入过多的数据准备和逻辑。考虑使用更明确的导航方法或路由机制。 利用扩展 (Extensions)： 将 Controller 中不同职责的代码划分到不同的扩展文件中（例如 MyViewController+Network.swift, MyViewController+TableView.swift），提高可读性，但逻辑上还在同一个类里。 MVC 的替代方案： 为了解决 MVC 在 iOS 中固有的问题，出现了多种替代架构模式：\nMVVM (Model-View-ViewModel)： 引入 ViewModel 层，负责将 Model 数据转换为 View 可直接显示的数据，并包含视图相关的状态和命令。View 和 ViewModel 通过数据绑定（如 Combine, RxSwift）连接，大大减少了 Controller（或 View，在 SwiftUI 中）的职责。这是目前最流行的替代方案，尤其适合 SwiftUI。 VIPER (View-Interactor-Presenter-Entity-Router)： 将职责划分得更加细致（路由、业务逻辑、展示逻辑、实体），每个组件职责单一且明确，可测试性极高。但引入的复杂性和文件数量也显著增加，适合大型、长期维护的项目。 MVP (Model-View-Presenter)： 类似于 MVVM，但 View 和 Presenter 之间通常通过接口/协议进行通信，强调被动 View。在 iOS 中不如 MVVM 流行。 Clean Architecture / TCA (The Composable Architecture)： 强调分层（Entities, Use Cases, Interface Adapters, Frameworks \u0026amp; Drivers）、依赖规则（依赖向内指向核心业务逻辑）、单向数据流。TCA 是基于 Swift 的一个具体实现，结合了 Elm 和 Redux 的思想，提供强大的状态管理和可测试性。 总结： MVC 是一个基础且重要的架构模式，理解其核心思想和在 iOS 中的具体实现（以及由此引发的 Massive View Controller 问题）是 iOS 开发者的必备知识。虽然它在小型项目或简单界面上仍然有效且快速，但在面对复杂应用时，其缺点会变得非常突出。\n对于新项目：\n如果主要使用 SwiftUI，MVVM 是非常自然且推荐的选择。 如果主要使用 UIKit，强烈推荐学习和采用 MVVM（通常结合 Combine 或 RxSwift 进行数据绑定）来避免 Massive View Controller。VIPER 或 Clean Architecture/TCA 是更高级的选择，适用于对可维护性、可测试性要求极高的大型项目。 对于维护遗留的 UIKit MVC 项目： 了解 MVC 的原理和问题所在，并逐步应用上述的“缓解策略”进行重构，或者在有条件和收益的情况下，逐步向 MVVM 等模式迁移部分功能模块。\n","date":"2025-06-09T21:11:31+08:00","image":"https://tc.z.wiki/autoupload/LLDBPtgBr9Urin7-1d1Bk_nFSiw33MlPagvUIGEPh-ayl5f0KlZfm6UsKj-HyTuv/20250609/sDey/743X194/image.png","permalink":"https://muo123.github.io/p/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mvc%E6%9E%B6%E6%9E%84/","title":"深入了解MVC架构"},{"content":"以下是 Hugo + GitHub Pages 博客搭建全流程指南，从环境配置到自动化部署，附详细代码和避坑提示：\n一、环境准备 ( Windows ) 1. 安装 Git 下载地址：https://git-scm.cn/\n去 Git 官网下载对应版本，如无意外选择 x64 版本安装即可\n安装成功后可以在开始菜单栏看到 Git 文件夹以及相关 Git 工具 2. 安装 Hugo 下载地址： https://github.com/gohugoio/hugo/releases\n下载 Hugo 扩展版（支持 Sass/SCSS） (选 hugo_extended_*.zip) 解压到 D:\\Hugo 并将路径加入系统环境变量 PATH 3. 创建本地项目 创建项目。在任意文件夹（图例为 D 盘）打开控制台，并输入指令 hugo new site xxx(你的项目名) 运行服务。切换至该目录，并输入指令 hugo server，网址输入localhost:1313，此时由于没有主题内容，显示 page not found，在控制台输入Ctrl + C即可关闭服务 二、项目配置 1. 添加主题（以 Stack 为例） 可以选择从官网下载，选择喜欢的主题并下载压缩包，解压到 themes 文件夹\n官网地址：https://themes.gohugo.io/\n或者使用 git 指令下载对应主题\n1 2 # 将主题添加为 Git 子模块（避免直接复制文件） git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack 2. 基础配置 个人编写 hugo.toml 比较耗费时间，下载的主题文件夹中一般包含网站实例 exampleSite，可以将里面的 content 文件夹和 hugo.yaml 配置文件拷贝到当前目录，并覆盖博客目录相关文件。覆盖目录文件后，可能出现兼容性报错，此时需要删除 Content/post/rich-content。另外，相关语言配置项根据需要进行合理修改\n3. 创建第一篇文章 1 hugo new posts/hello.md 编辑 content/posts/hello-world.md：\n1 2 3 4 5 6 7 +++ date = \u0026#39;2025-06-02T22:12:41+08:00\u0026#39; draft = true title = \u0026#39;Hello\u0026#39; +++ this is a test 三、本地预览 1 hugo server -D # -D 包含草稿 访问 https://localhost:1313 实时预览\n四、部署到 GitHub Pages 方案一：手动部署（适合初学者） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 构建静态文件（生成到 public 目录） hugo --minify # 2. 创建 GitHub 仓库：\u0026lt;你的用户名\u0026gt;.github.io # 3. 第一次推送代码之前需要进行如下配置 git config --global user.name \u0026#34;你的 GitHub 用户名\u0026#34; git config --global user.email \u0026#34;你注册 GitHub 的邮箱\u0026#34; # 4. 将 public 目录推送到仓库 cd public git init git add . git remote add origin git@Github.com:\u0026lt;用户名\u0026gt;/\u0026lt;用户名\u0026gt;.github.io.git (需要设置ssh) \u0026gt;\u0026gt;\u0026gt; 或者使用指令 git remote add origin https://github.com/\u0026lt;用户名\u0026gt;/\u0026lt;用户名\u0026gt;.github.io.git git commit -m \u0026#34;Initial deploy\u0026#34; git push -u origin main 方案二：自动化部署（推荐！使用 GitHub Actions） 创建新仓库 1 2 3 4 5 \u0026gt; 创建一个用来储存所有博客文件的新仓库，权限设置为 `private` \u0026gt; 前往 Settings/Developer Settings/Personal access tokens , 点击 “Generate new token (classic)” 创建一个 token，并勾选 repo 和 workflow 选项 \u0026gt; 复制 token，前往新仓库的 Settings/Secrets and variables/Actions，点击 New repository secret 将 token 保存在仓库的环境变量中。 博客项目根目录创建 .github/workflows/deploy.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: blog deploy on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest\tsteps: - uses: actions/checkout@v4\twith: submodules: true fetch-depth: 0 - name: Setup Hugo\tuses: peaceiris/actions-hugo@v3\twith: hugo-version: \u0026#39;latest\u0026#39;\textended: true - name: Build run: hugo -D - name: Deploy uses: peaceiris/actions-gh-pages@v4\twith: external_repository: xxx/xxx.github.io\t# 自己的GitHub pages仓库 personal_token: ${{ secrets.你的token变量名 }} publish_dir: ./public\tpublish_branch: main\t可以在目录创建 .gitignore 文件，避免提交部分文件，例如\n1 2 3 public resources .hugo_build.lock 推送代码到 GitHub 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;Add workflow\u0026#34; git remote add origin git@Github.com:\u0026lt;用户名\u0026gt;/\u0026lt;用户名\u0026gt;.github.io.git (需要设置ssh) \u0026gt;\u0026gt;\u0026gt; 或者使用指令 git remote add origin https://github.com/\u0026lt;用户名\u0026gt;/\u0026lt;用户名\u0026gt;.github.io.git git push -u origin main 五、访问与优化 访问地址\nhttps://\u0026lt;用户名\u0026gt;.github.io (首次部署需等待 1-2 分钟)\n自定义域名（可选）\n在项目根目录添加 static/CNAME 文件，内容为域名： 1 blog.yourdomain.com DNS 添加 CNAME 记录指向 \u0026lt;用户名\u0026gt;.github.io 强制 HTTPS\n在 GitHub Pages 设置中勾选 Enforce HTTPS\n六、常用命令速查 命令 作用 hugo new posts/标题.md 新建文章 hugo server -D 启动本地服务器（含草稿） hugo --minify 构建优化后的静态文件 git submodule update --remote 更新主题 七、避坑指南 主题无法加载\n确保使用 git submodule 添加主题 在 Actions 中启用 submodules: recursive 构建失败\n检查 .github/workflows/deploy.yml 中的 Hugo 版本是否匹配 确保使用 extended 版本（如果主题需要 SCSS） 中文乱码\n在文章 Front Matter 中明确指定编码：\n1 charset: utf-8 自定义布局\n复制主题文件到本地覆盖（避免直接修改主题）：\n1 cp themes/stack/layouts/_default/single.html layouts/ 效果预览 完成部署后，你将获得：\n⚡ 基于 Hugo 的极速静态博客 🤖 自动化 Git 工作流（提交即发布） 📱 响应式主题适配移动端 🔒 免费 HTTPS 支持 立即开始你的博客之旅吧！升级方案可添加：\nAlgolia 搜索（hugo-algolia） Utterances 评论系统（GitHub Issue 驱动） 流量统计（Google Analytics/Umami） ","date":"2025-06-03T11:02:43+08:00","image":"https://tc.z.wiki/autoupload/20250603/UrPE/1602X637/image.png","permalink":"https://muo123.github.io/p/hugo--github-pages-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"Hugo + Github Pages 博客搭建"},{"content":"以下是 Hugo、Hexo 和 Jekyll 三大主流静态博客框架的详细对比，从核心特性到适用场景的全方位分析，帮助你快速选择最适合的工具：\n核心区别对比表 特性 Hugo Hexo Jekyll 开发语言 Go（单二进制文件） Node.js Ruby 构建速度 ⚡ 极快（千页秒级） 🚀 快（依赖插件复杂度） ⏳ 较慢（大型项目可能需分钟级） GitHub Pages 支持 ❌ 需本地构建后推送产物 ❌ 需本地构建后推送产物 ✅ 原生支持（自动构建） 安装复杂度 ★☆☆（无需环境，下载即用） ★★☆（需 Node.js 环境） ★★★（需 Ruby 环境及 Bundler） 主题生态 丰富（Hugo Themes） 极丰富（Hexo Themes） 成熟（Jekyll Themes） 插件扩展性 中等（内置短代码/部分插件） ✅ 极强（600+ 插件） 良好（Gem 插件） 模板引擎 Go Templates（学习曲线陡） EJS/Swig/Pug（灵活） Liquid（易上手） 内容管理 灵活（支持自定义内容类型） 标准 Markdown + Front Matter 标准 Markdown + Front Matter 适用人群 大型站点/效率优先者 前端开发者/插件爱好者 GitHub 新手/讨厌本地构建者 深度解析三大框架 1. Hugo：速度至上的极简主义 优势 无需依赖环境：单文件执行，解压即用，跨平台无兼容问题。 极致构建速度：千篇文章构建仅需 2-5 秒，适合频繁更新的大型博客。 强类型内容模型：可自定义内容结构（如技术文档、作品集）。 劣势 Go Templates 语法较复杂（例如条件判断需写 {{ if eq .A .B }}）。 插件生态弱于 Hexo，高级功能需手动开发。 典型用户：技术博主、文档站点维护者、讨厌等待构建的人。 2. Hexo：前端开发者的瑞士军刀 优势 插件驱动：支持图床优化（hexo-asset-image）、SEO 增强（hexo-seo）等深度定制。 技术栈亲和：基于 Node.js，前端开发者可无缝接入 Webpack/Babel 等工具。 主题高度自由：可修改主题源码，自由度远超 Hugo/Jekyll 的主题配置。 劣势 插件过多可能导致构建缓慢（需谨慎选择插件）。 需熟悉 Node.js 开发环境（版本兼容问题常见）。 典型用户：前端工程师、需要深度定制的技术博主。 3. Jekyll：GitHub 亲儿子的零配置方案 优势 无缝 GitHub 集成：推送 Markdown 即自动发布，无需本地构建。 低学习曲线：Liquid 模板类似自然语言（例：{% if page.title %}）。 官方维护保障：GitHub 官方支持，兼容性无忧。 劣势 Ruby 环境在 Windows 易出错（需 RubyInstaller + DevKit）。 百篇文章以上构建显著变慢（\u0026gt;30秒）。 典型用户：写作优先的博主、非技术背景用户、小型项目快速上线。 关键决策场景 你的需求 推荐框架 原因 纯写作/讨厌命令行 Jekyll 推送 Markdown 即发布，无需构建 博客规模大（\u0026gt;500篇文章） Hugo 构建速度碾压对手，节省生命 前端开发者/爱折腾插件 Hexo 用 Node.js 生态定制功能（如 PWA 支持） 需托管 GitHub 且追求稳定 Jekyll 官方支持，无构建失败风险 多语言站点（i18n） Hugo 内置多语言支持，配置简单 终极选择建议 选 Hugo 如果：你追求效率至上，内容量巨大，或抗拒环境配置。 选 Hexo 如果：你是前端开发者，需要插件拓展功能（如 Algolia 搜索）。 选 Jekyll 如果：你希望完全依赖 GitHub 自动化，专注写作而非技术。 💡 部署提示：\nHugo/Hexo 可用 GitHub Actions 自动化构建（示例脚本）。 避免将 node_modules/public 推送到 Git 仓库（用 .gitignore 过滤）。 ","date":"2025-06-02T23:23:47+08:00","image":"https://tc.z.wiki/autoupload/20250603/5th1/848X557/image.png","permalink":"https://muo123.github.io/p/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6-hugohexojekyll-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AF%B9%E6%AF%94/","title":"博客框架 Hugo，Hexo，Jekyll 三者的区别和对比"},{"content":"在 GitHub Pages 上搭建个人博客是极佳的选择（免费、稳定、易用），而选择合适的静态网站生成框架至关重要。以下是主流且与 GitHub Pages 配合良好的框架，以及它们之间的核心区别：\n🎈 主流框架推荐 Jekyll\n官方支持： GitHub Pages 原生支持 Jekyll。这意味着你只需将 Jekyll 源文件推送到仓库，GitHub 会自动为你构建网站。无需本地构建或上传 _site 目录。 语言： Ruby 特点： 简单易上手： 主题、插件丰富，文档完善，社区庞大，非常适合初学者。 约定优于配置： 遵循特定目录结构，很多功能开箱即用。 Liquid 模板引擎： 灵活但学习曲线相对平缓。 Markdown 支持： 内置支持，方便写作。 优势： 与 GitHub Pages 集成最无缝，部署最省心。 劣势： 构建速度在大型站点上相对较慢；需要 Ruby 环境进行本地开发。 Hugo\n官方支持： GitHub Pages 不原生支持 Hugo。你需要在本地构建网站（生成 public 目录），然后将这个 public 目录的内容推送到 GitHub 仓库（通常是 gh-pages 分支或特定分支/docs 目录）。 语言： Go (编译成单个二进制文件) 特点： 极速构建： 最大的优势！构建成千上万页面也只需几秒到十几秒。 单二进制文件： 安装部署极其简单，无需复杂的语言环境。 强大灵活： 内容组织方式灵活，模板功能强大（Go Templates）。 主题丰富： 拥有非常庞大且活跃的主题生态系统。 优势： 无与伦比的构建速度，本地开发体验极佳，部署简单（虽然需要本地构建）。 劣势： Go Templates 学习曲线可能比 Liquid 稍陡；需要手动构建后部署到 GitHub Pages。 Hexo\n官方支持： GitHub Pages 不原生支持 Hexo。需要本地构建（生成 public 目录），然后推送 public 目录内容。 语言： Node.js 特点： 快速高效： 构建速度较快（虽然通常不及 Hugo）。 插件驱动： 拥有海量的插件，功能扩展性极强。 主题丰富： 主题数量众多，风格多样。 面向博客优化： 对博客所需的标签、分类、归档等支持良好。 优势： 基于 Node.js，对前端开发者友好；插件生态强大，可定制性高。 劣势： 需要 Node.js 环境；配置可能相对复杂一些。 VuePress / VitePress\n官方支持： GitHub Pages 不原生支持。需要本地构建，推送构建产物（通常是 .vuepress/dist 或 .vitepress/dist）。 语言： Node.js (基于 Vue.js) 特点： 技术栈驱动： 专为技术文档设计，但对博客也非常适合，尤其适合熟悉 Vue.js 的开发者。 Markdown 扩展强大： 可以在 Markdown 中直接使用 Vue 组件，实现高度交互性。 默认主题优秀： 官方默认主题简洁美观，功能实用。 开发体验好： 基于 Vite，启动和热更新速度极快。 优势： 技术文档和博客的完美结合；利用 Vue 组件系统实现高度定制；优秀的开发体验。 劣势： 对不熟悉 Vue 的开发者有一定门槛；主题和插件生态相对 Jekyll/Hugo/Hexo 规模小些（但增长快）。 Eleventy (11ty)\n官方支持： GitHub Pages 不原生支持。需要本地构建，推送构建产物（可配置）。 语言： Node.js 特点： 极度灵活与简单： 零配置默认值，但可深度定制。支持多种模板语言（Liquid, Nunjucks, Handlebars, Markdown, HTML 等），你可以混用。 轻量级： 框架本身非常精简，概念少。 高性能： 构建速度很快。 “无框架”框架： 更倾向于提供核心的静态生成能力，不强制特定的项目结构或数据模型。 优势： 极高的灵活性和自由度；学习曲线相对平缓（尤其如果你熟悉其中一种模板语言）；性能优异。 劣势： 需要自己搭建更多东西（相比开箱即用的框架）；主题生态不如前几个成熟；需要 Node.js 环境。 Astro\n官方支持： GitHub Pages 不原生支持。需要本地构建，推送构建产物（dist 目录）。 语言： Node.js (但组件理念独特) 特点： 岛屿架构： 核心理念！默认输出纯静态 HTML/CSS，但可以按需“激活”页面上的交互式组件（称为“岛屿”），大幅减少不必要的 JS。 框架无关： 可以在 .astro 组件中无缝使用 React, Vue, Svelte, Solid 等 UI 框架的组件。 高性能： 非常注重输出站点的性能（速度、SEO）。 内容优先： 对 Markdown/MDX 支持优秀，内置内容集合功能。 优势： 构建现代、高性能网站的最佳选择之一；独特的架构带来极佳的用户体验；强大的内容管理能力；灵活的组件系统。 劣势： 概念较新，学习曲线相对陡峭；需要 Node.js 环境；生态还在快速发展中。 🔍 核心区别对比表 特性 Jekyll Hugo Hexo VuePress/VitePress Eleventy (11ty) Astro 原生 GitHub Pages 支持 ✅ 是 (自动构建) ❌ 否 (需本地构建) ❌ 否 (需本地构建) ❌ 否 (需本地构建) ❌ 否 (需本地构建) ❌ 否 (需本地构建) 开发语言 Ruby Go (单二进制) Node.js Node.js (Vue) Node.js Node.js 最大优势 与 GitHub Pages 集成 极速构建 插件生态强大 Markdown+Vue组件 灵活简单，多模板 岛屿架构，高性能 构建速度 较慢 (大型站点) ⚡ 极快 快 快 (VitePress 更快) 快 快 学习曲线 平缓 中等 (Go模板) 中等 中等 (需Vue基础) 平缓 (熟悉模板即可) 较陡 (新概念) 主题生态 非常丰富 非常丰富 非常丰富 良好 (官方主题优秀) 增长中 增长迅速 插件/扩展性 良好 良好 (短代码等) ✅ 极好 良好 良好 (通过配置/JS) 良好 (集成框架能力强) 灵活性/自由度 中等 高 高 高 (Vue组件) ✅ 极高 高 最适合人群 新手/GitHub集成优先 讨厌等待/大型站点 前端开发者/插件爱好者 Vue开发者/技术文档 追求简洁自由/多语言者 性能控/现代框架使用者 📌 选择建议 追求最简单部署，不想本地构建：选 Jekyll。 GitHub 替你搞定一切，专注于写作。 博客规模大或无法忍受慢速构建：选 Hugo。 速度是王道，部署步骤也简单。 前端开发者，喜欢丰富的插件和主题：选 Hexo。 Node.js 环境很熟悉，扩展性强。 熟悉 Vue.js 或需要强交互/技术文档：选 VuePress / VitePress。 Markdown + Vue 的组合非常强大，开发体验好。 喜欢简洁、灵活、自由度高，不依赖特定框架：选 Eleventy。 用你喜欢的模板语言，按你的方式组织。 构建高性能、现代化网站，想用不同框架组件：选 Astro。 岛屿架构带来卓越性能，未来感十足。 💡 重要提示 部署方式： 只有 Jekyll 享受 GitHub Pages 的原生构建支持。对于其他框架，你必须在本地或通过 GitHub Actions 等 CI/CD 工具完成构建，然后将生成的静态文件（通常是 public, dist, _site, docs 等目录）推送到仓库的特定分支（如 gh-pages）或主分支的特定目录（如 /docs），并在仓库设置中指定源。 GitHub Actions： 对于非 Jekyll 框架，强烈推荐使用 GitHub Actions 自动化构建和部署过程。这样你只需推送源代码，Actions 会自动执行构建并将生成的静态文件部署到 GitHub Pages。官方或社区通常提供现成的 Action 工作流。 考虑熟悉度： 选择你或你的团队最熟悉的语言和技术的框架，会大大降低学习成本和开发效率。 需求驱动： 明确你的博客需求（纯写作？需要复杂功能？需要极致性能？需要特定技术栈集成？），再根据需求选择最匹配的框架。 🎯 总结 GitHub Pages 为静态博客提供了优秀的托管平台。Jekyll 凭借其原生集成是最省心的选择。Hugo 凭借无与伦比的构建速度是大型站点或追求效率者的首选。Hexo 以其强大的插件生态吸引 Node.js 开发者。VuePress/VitePress 是 Vue 技术栈和文档需求的绝配。Eleventy 提供了最大的灵活性和简洁性。Astro 则代表了现代高性能 Web 开发的方向。\n根据你的具体需求、技术偏好和对部署流程的接受程度，仔细权衡以上框架的特点，就能找到最适合你在 GitHub Pages 上搭建个人博客的工具！开始构建你的博客之旅吧！\n","date":"2025-06-02T22:52:19+08:00","image":"https://tc.z.wiki/autoupload/20250603/sjGQ/1085X637/image.png","permalink":"https://muo123.github.io/p/github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B/","title":"Github Pages 搭建个人博客可供选择的框架有哪些"}]