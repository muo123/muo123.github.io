<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C/C++ on 雪国流明</title><link>https://muo123.github.io/tags/c/c++/</link><description>Recent content in C/C++ on 雪国流明</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>muo123</copyright><lastBuildDate>Tue, 24 Jun 2025 20:59:42 +0800</lastBuildDate><atom:link href="https://muo123.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++智能指针</title><link>https://muo123.github.io/articles/c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link><pubDate>Tue, 24 Jun 2025 20:44:29 +0800</pubDate><guid>https://muo123.github.io/articles/c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid><description>&lt;h3 id="c-智能指针详解">C++ 智能指针详解
&lt;/h3>&lt;p>C++ 智能指针是管理动态内存的现代化工具，通过自动内存释放避免内存泄漏。它们定义在 &lt;code>&amp;lt;memory&amp;gt;&lt;/code> 头文件中，遵循 RAII（资源获取即初始化）原则。以下是三种主要智能指针的详细说明和代码示例：&lt;/p>
&lt;hr>
&lt;h4 id="1-stdunique_ptr独占所有权指针">1. &lt;code>std::unique_ptr&lt;/code>（独占所有权指针）
&lt;/h4>&lt;p>&lt;code>std::unique_ptr&lt;/code>是一种独占所有权的智能指针。同一时间只能有一个&lt;code>unique_ptr&lt;/code>指向一个给定的对象。当&lt;code>unique_ptr&lt;/code>被销毁（例如离开作用域）时，它所指向的对象也会被自动删除。
&lt;strong>特性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>独占资源所有权（不可复制）&lt;/li>
&lt;li>支持移动语义（所有权可转移）&lt;/li>
&lt;li>可管理数组（&lt;code>unique_ptr&amp;lt;T[]&amp;gt;&lt;/code>）&lt;/li>
&lt;li>自定义删除器支持&lt;/li>
&lt;li>零运行时开销（与裸指针性能相当）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>代码示例&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>&lt;span style="color:#ff6ac1">using&lt;/span> &lt;span style="color:#ff6ac1">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span> &lt;span style="color:#57c7ff">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 创建 unique_ptr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> unique_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>&lt;span style="color:#9aedfe">int&lt;/span>&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> ptr1(&lt;span style="color:#ff6ac1">new&lt;/span> &lt;span style="color:#9aedfe">int&lt;/span>(&lt;span style="color:#ff9f43">42&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ff6ac1">*&lt;/span>ptr1 &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: 42
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 移动所有权（转移后 ptr1 为空）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> unique_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>&lt;span style="color:#9aedfe">int&lt;/span>&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> ptr2 &lt;span style="color:#ff6ac1">=&lt;/span> move(ptr1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> (ptr1 &lt;span style="color:#ff6ac1">?&lt;/span> &lt;span style="color:#5af78e">&amp;#34;非空&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">:&lt;/span> &lt;span style="color:#5af78e">&amp;#34;空&amp;#34;&lt;/span>) &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: 空
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 管理数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> unique_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>&lt;span style="color:#9aedfe">int&lt;/span>[]&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> arr(&lt;span style="color:#ff6ac1">new&lt;/span> &lt;span style="color:#9aedfe">int&lt;/span>[&lt;span style="color:#ff9f43">3&lt;/span>]{&lt;span style="color:#ff9f43">1&lt;/span>, &lt;span style="color:#ff9f43">2&lt;/span>, &lt;span style="color:#ff9f43">3&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> arr[&lt;span style="color:#ff9f43">1&lt;/span>] &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 自定义删除器（示例：文件指针）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">auto&lt;/span> fileDeleter &lt;span style="color:#ff6ac1">=&lt;/span> [](FILE&lt;span style="color:#ff6ac1">*&lt;/span> f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">if&lt;/span>(f) fclose(f);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;文件已关闭&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>FILE, &lt;span style="color:#ff6ac1">decltype&lt;/span>(fileDeleter)&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> filePtr(fopen(&lt;span style="color:#5af78e">&amp;#34;test.txt&amp;#34;&lt;/span>, &lt;span style="color:#5af78e">&amp;#34;w&amp;#34;&lt;/span>), fileDeleter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">return&lt;/span> &lt;span style="color:#ff9f43">0&lt;/span>; &lt;span style="color:#78787e">// 自动释放所有资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h4 id="2-stdshared_ptr共享所有权指针">2. &lt;code>std::shared_ptr&lt;/code>（共享所有权指针）
&lt;/h4>&lt;p>&lt;code>std::shared_ptr&lt;/code>是一种共享所有权的智能指针。多个&lt;code>shared_ptr&lt;/code>可以指向同一个对象，并通过引用计数来管理对象的生命周期。当最后一个&lt;code>shared_ptr&lt;/code>被销毁时，对象才会被删除。
&lt;strong>特性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>多个指针共享同一对象&lt;/li>
&lt;li>基于引用计数（自动归零时销毁对象）&lt;/li>
&lt;li>支持自定义删除器&lt;/li>
&lt;li>线程安全（引用计数原子操作）&lt;/li>
&lt;li>使用 &lt;code>make_shared&lt;/code> 更高效（单次内存分配）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>代码示例&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>&lt;span style="color:#ff6ac1">using&lt;/span> &lt;span style="color:#ff6ac1">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">class&lt;/span> &lt;span style="color:#f3f99d">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">public&lt;/span>&lt;span style="color:#ff6ac1">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyClass() { cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;构造函数&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">~&lt;/span>MyClass() { cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;析构函数&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#9aedfe">void&lt;/span> &lt;span style="color:#57c7ff">greet&lt;/span>() { cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;Hello!&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span> &lt;span style="color:#57c7ff">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 推荐创建方式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> shared_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>MyClass&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> ptr1 &lt;span style="color:#ff6ac1">=&lt;/span> make_shared&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>MyClass&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ptr1&lt;span style="color:#ff6ac1">-&amp;gt;&lt;/span>greet(); &lt;span style="color:#78787e">// 输出: Hello!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 共享所有权（引用计数+1）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> shared_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>MyClass&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> ptr2 &lt;span style="color:#ff6ac1">=&lt;/span> ptr1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;引用计数: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> ptr1.use_count() &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> } &lt;span style="color:#78787e">// ptr2 析构，引用计数-1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;引用计数: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> ptr1.use_count() &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 自定义删除器示例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> shared_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>&lt;span style="color:#9aedfe">int&lt;/span>&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> customDel(&lt;span style="color:#ff6ac1">new&lt;/span> &lt;span style="color:#9aedfe">int&lt;/span>[&lt;span style="color:#ff9f43">5&lt;/span>], [](&lt;span style="color:#9aedfe">int&lt;/span>&lt;span style="color:#ff6ac1">*&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">delete&lt;/span>[] p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;自定义释放数组&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">return&lt;/span> &lt;span style="color:#ff9f43">0&lt;/span>; &lt;span style="color:#78787e">// 自动释放所有资源（输出析构函数）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h4 id="3-stdweak_ptr弱引用指针">3. &lt;code>std::weak_ptr&lt;/code>（弱引用指针）
&lt;/h4>&lt;p>&lt;code>std::weak_ptr&lt;/code>是一种不控制对象生命周期的智能指针，它指向一个由&lt;code>shared_ptr&lt;/code>管理的对象。&lt;code>weak_ptr&lt;/code>不会增加引用计数，因此它不会影响对象的生命周期。主要用于解决&lt;code>shared_ptr&lt;/code>的循环引用问题。
&lt;strong>特性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>解决 &lt;code>shared_ptr&lt;/code> 循环引用问题&lt;/li>
&lt;li>不增加引用计数&lt;/li>
&lt;li>需通过 &lt;code>lock()&lt;/code> 转为 &lt;code>shared_ptr&lt;/code> 访问对象&lt;/li>
&lt;li>检查资源是否有效&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>代码示例（含循环引用解决方案）&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>&lt;span style="color:#ff6ac1">using&lt;/span> &lt;span style="color:#ff6ac1">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">class&lt;/span> &lt;span style="color:#f3f99d">Node&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">public&lt;/span>&lt;span style="color:#ff6ac1">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> weak_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>Node&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> partner; &lt;span style="color:#78787e">// 关键：使用 weak_ptr 打破循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node(string n) &lt;span style="color:#ff6ac1">:&lt;/span> name(move(n)) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">~&lt;/span>Node() { cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> name &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34; 被销毁&amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span> &lt;span style="color:#57c7ff">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shared_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>Node&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> alice &lt;span style="color:#ff6ac1">=&lt;/span> make_shared&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>Node&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span>(&lt;span style="color:#5af78e">&amp;#34;Alice&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shared_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>Node&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> bob &lt;span style="color:#ff6ac1">=&lt;/span> make_shared&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>Node&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span>(&lt;span style="color:#5af78e">&amp;#34;Bob&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 建立双向关联（不会导致循环引用）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> alice&lt;span style="color:#ff6ac1">-&amp;gt;&lt;/span>partner &lt;span style="color:#ff6ac1">=&lt;/span> bob;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bob&lt;span style="color:#ff6ac1">-&amp;gt;&lt;/span>partner &lt;span style="color:#ff6ac1">=&lt;/span> alice;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 访问对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">if&lt;/span> (&lt;span style="color:#ff6ac1">auto&lt;/span> ptr &lt;span style="color:#ff6ac1">=&lt;/span> alice&lt;span style="color:#ff6ac1">-&amp;gt;&lt;/span>partner.lock()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;Alice 的伙伴: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> ptr&lt;span style="color:#ff6ac1">-&amp;gt;&lt;/span>name &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: Bob
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;Alice 引用计数: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> alice.use_count() &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#78787e">// 输出: 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">return&lt;/span> &lt;span style="color:#ff9f43">0&lt;/span>; &lt;span style="color:#78787e">// 正确销毁两个对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="关键特性对比表">关键特性对比表
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>特性&lt;/th>
&lt;th>&lt;code>unique_ptr&lt;/code>&lt;/th>
&lt;th>&lt;code>shared_ptr&lt;/code>&lt;/th>
&lt;th>&lt;code>weak_ptr&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>所有权&lt;/strong>&lt;/td>
&lt;td>独占&lt;/td>
&lt;td>共享&lt;/td>
&lt;td>无所有权&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>复制语义&lt;/strong>&lt;/td>
&lt;td>❌ 禁止&lt;/td>
&lt;td>✅ 允许&lt;/td>
&lt;td>✅ 允许&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>移动语义&lt;/strong>&lt;/td>
&lt;td>✅ 支持&lt;/td>
&lt;td>✅ 支持&lt;/td>
&lt;td>✅ 支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>引用计数&lt;/strong>&lt;/td>
&lt;td>无&lt;/td>
&lt;td>✅ 有&lt;/td>
&lt;td>不增加计数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>释放时机&lt;/strong>&lt;/td>
&lt;td>指针析构时&lt;/td>
&lt;td>引用计数归零时&lt;/td>
&lt;td>不管理释放&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>数组支持&lt;/strong>&lt;/td>
&lt;td>&lt;code>unique_ptr&amp;lt;T[]&amp;gt;&lt;/code>&lt;/td>
&lt;td>需自定义删除器&lt;/td>
&lt;td>❌ 不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>线程安全&lt;/strong>&lt;/td>
&lt;td>非原子操作&lt;/td>
&lt;td>引用计数原子操作&lt;/td>
&lt;td>依赖关联的 shared_ptr&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>典型用途&lt;/strong>&lt;/td>
&lt;td>独占资源管理&lt;/td>
&lt;td>共享资源&lt;/td>
&lt;td>打破循环引用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="最佳实践">最佳实践
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>优先使用 &lt;code>make_shared&lt;/code>/&lt;code>make_unique&lt;/code>&lt;/strong>（C++14+）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">auto&lt;/span> ptr &lt;span style="color:#ff6ac1">=&lt;/span> make_shared&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>MyClass&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span>(); &lt;span style="color:#78787e">// 替代 shared_ptr(new MyClass)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>单次内存分配（提升性能）&lt;/li>
&lt;li>避免裸指针异常导致的内存泄漏&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>避免混用智能指针和裸指针&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span>&lt;span style="color:#ff6ac1">*&lt;/span> raw &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff6ac1">new&lt;/span> &lt;span style="color:#9aedfe">int&lt;/span>(&lt;span style="color:#ff9f43">10&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>shared_ptr&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>&lt;span style="color:#9aedfe">int&lt;/span>&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> p1(raw);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">// shared_ptr&amp;lt;int&amp;gt; p2(raw); // 灾难性错误：重复释放
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>循环引用解决方案&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>weak_ptr&lt;/code> 替代 &lt;code>shared_ptr&lt;/code> 作为非拥有性引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能敏感场景&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优先使用 &lt;code>unique_ptr&lt;/code>（零开销抽象）&lt;/li>
&lt;li>避免频繁复制 &lt;code>shared_ptr&lt;/code>（原子操作开销）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>资源释放验证&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在删除器中添加调试输出&lt;/li>
&lt;li>使用 Valgrind 或 AddressSanitizer 检查内存泄漏&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>通过合理使用智能指针，可消除 90% 以上的内存管理错误，是现代 C++ 资源管理的核心工具。&lt;/p></description></item><item><title>快速排序C++实现</title><link>https://muo123.github.io/articles/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fc-%E5%AE%9E%E7%8E%B0/</link><pubDate>Sun, 22 Jun 2025 19:51:01 +0800</pubDate><guid>https://muo123.github.io/articles/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fc-%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>快速排序（Quick Sort）是一种高效的排序算法，采用分治法（Divide and Conquer）策略。它的基本思想是：选择一个基准元素（pivot），通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有元素都比基准元素小，另一部分的所有元素都比基准元素大，然后再按此方法对这两部分数据分别进行快速排序，整个过程递归进行，直到整个数据变成有序序列。&lt;/p>
&lt;h3 id="算法步骤">算法步骤：
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>选择基准（Pivot Selection）&lt;/strong>：从数组中选择一个元素作为基准（pivot）。选择方式有多种，例如可以选择第一个元素、最后一个元素、中间元素或随机元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区（Partitioning）&lt;/strong>：重新排列数组，使得所有小于基准的元素都放在基准前面，所有大于基准的元素都放在基准后面（相等的数可以到任一边）。在这个分区结束之后，该基准就处于数组的中间位置。这个称为分区操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>递归排序（Recursion）&lt;/strong>：递归地将小于基准元素的子数组和大于基准元素的子数组排序。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="算法实现">算法实现
&lt;/h3>&lt;h4 id="核心思路">核心思路
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>基准选择&lt;/strong>：选择中间元素作为基准值（&lt;code>x = a[l + r &amp;gt;&amp;gt; 1]&lt;/code>）&lt;/li>
&lt;li>&lt;strong>双指针扫描&lt;/strong>：使用左右指针&lt;code>i&lt;/code>和&lt;code>j&lt;/code>分别从两端向中间扫描&lt;/li>
&lt;li>&lt;strong>元素交换&lt;/strong>：交换不符合分区规则的逆序对&lt;/li>
&lt;li>&lt;strong>递归分区&lt;/strong>：将数组分成两个子数组递归处理&lt;/li>
&lt;/ol>
&lt;h4 id="代码逐行解析">代码逐行解析
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">void&lt;/span> &lt;span style="color:#57c7ff">quick_sort&lt;/span>(&lt;span style="color:#9aedfe">int&lt;/span> a[], &lt;span style="color:#9aedfe">int&lt;/span> l, &lt;span style="color:#9aedfe">int&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">if&lt;/span>(l &lt;span style="color:#ff6ac1">&amp;gt;=&lt;/span> r) &lt;span style="color:#ff6ac1">return&lt;/span>; &lt;span style="color:#78787e">// 递归终止条件：子数组长度≤1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 初始化指针（扩大边界）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#9aedfe">int&lt;/span> i &lt;span style="color:#ff6ac1">=&lt;/span> l&lt;span style="color:#ff6ac1">-&lt;/span>&lt;span style="color:#ff9f43">1&lt;/span>, j &lt;span style="color:#ff6ac1">=&lt;/span> r&lt;span style="color:#ff6ac1">+&lt;/span>&lt;span style="color:#ff9f43">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 选择中间元素作为基准（位运算等价于(l+r)/2）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#9aedfe">int&lt;/span> x &lt;span style="color:#ff6ac1">=&lt;/span> a[l&lt;span style="color:#ff6ac1">+&lt;/span>r&lt;span style="color:#ff6ac1">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ff9f43">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">while&lt;/span>(i &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 左指针向右找到≥基准的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">do&lt;/span> i&lt;span style="color:#ff6ac1">++&lt;/span>; &lt;span style="color:#ff6ac1">while&lt;/span>(a[i] &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 右指针向左找到≤基准的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">do&lt;/span> j&lt;span style="color:#ff6ac1">--&lt;/span>; &lt;span style="color:#ff6ac1">while&lt;/span>(a[j] &lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 交换逆序元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">if&lt;/span>(i &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> j) swap(a[i], a[j]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 递归处理子数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> quick_sort(a, l, j); &lt;span style="color:#78787e">// 左子数组[l, j]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> quick_sort(a, j&lt;span style="color:#ff6ac1">+&lt;/span>&lt;span style="color:#ff9f43">1&lt;/span>, r); &lt;span style="color:#78787e">// 右子数组[j+1, r]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="分区过程详解以数组311142857为例">分区过程详解（以数组{3,11,14,2,8,5,7}为例）
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>&lt;strong>初始状态&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>l=0, r=6, x=a[3]=2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>i=-1, j=7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[3, 11, 14, 2, 8, 5, 7]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>第一轮扫描&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>i++&lt;/code>直到a[i]≥2 → i=0 (3≥2)&lt;/li>
&lt;li>&lt;code>j--&lt;/code>直到a[j]≤2 → j=3 (2≤2)&lt;/li>
&lt;li>交换a[0]和a[3] → [2, 11, 14, 3, 8, 5, 7]&lt;/li>
&lt;li>继续扫描：i=1(11), j=2(14) → 交换 → [2, 14, 11, 3, 8, 5, 7]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二轮扫描&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>i→2(11), j→1(14) → i&amp;gt;j 循环结束&lt;/li>
&lt;li>当前分区：[2] 和 [14,11,3,8,5,7]&lt;/li>
&lt;li>j=1 (分区点)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>递归排序&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>quick_sort(a, &lt;span style="color:#ff9f43">0&lt;/span>, &lt;span style="color:#ff9f43">1&lt;/span>); &lt;span style="color:#78787e">// [2] (已有序)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>quick_sort(a, &lt;span style="color:#ff9f43">2&lt;/span>, &lt;span style="color:#ff9f43">6&lt;/span>); &lt;span style="color:#78787e">// 排序[14,11,3,8,5,7]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>后续递归&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>右子数组选择基准x=a[4]=8&lt;/li>
&lt;li>分区过程：
&lt;ul>
&lt;li>交换14↔7 → [7,11,3,8,5,14]&lt;/li>
&lt;li>交换11↔5 → [7,5,3,8,11,14]&lt;/li>
&lt;li>最终分区：[7,5,3] 和 [8,11,14]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="算法特点">算法特点
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>&lt;strong>高效分区&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>双指针同时扫描，平均交换次数更少&lt;/li>
&lt;li>&lt;code>do-while&lt;/code>确保至少移动一次指针，避免死循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>基准选择&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>中位数基准 (&lt;code>l+r&amp;gt;&amp;gt;1&lt;/code>) 避免已排序数组的最坏情况&lt;/li>
&lt;li>无需随机化（已满足平均O(n log n)）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>边界处理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>初始化&lt;code>i=l-1&lt;/code>, &lt;code>j=r+1&lt;/code>保证扫描全覆盖&lt;/li>
&lt;li>递归使用&lt;code>j&lt;/code>和&lt;code>j+1&lt;/code>作为分割点，确保分区不重叠&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="时间复杂度分析">时间复杂度分析
&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>情况&lt;/th>
&lt;th>时间复杂度&lt;/th>
&lt;th>发生条件&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>最佳&lt;/td>
&lt;td>O(n log n)&lt;/td>
&lt;td>每次均匀分区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>平均&lt;/td>
&lt;td>O(n log n)&lt;/td>
&lt;td>随机数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>最差&lt;/td>
&lt;td>O(n²)&lt;/td>
&lt;td>每次极不平衡分区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>空间复杂度&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>递归栈深度&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="执行流程示意图">执行流程示意图
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>原始: [3,11,14,2,8,5,7]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>基准: 2 (index3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>分区: [2] [14,11,3,8,5,7] // j=1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>右子数组: [14,11,3,8,5,7]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>基准: 8 (index4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>分区: [7,5,3] [8,11,14] // j=4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>左子数组: [7,5,3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>基准: 5 (index1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>分区: [3] [5,7] // j=1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>最终合并: [2,3,5,7,8,11,14]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="注意事项">注意事项
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>稳定性&lt;/strong>：快速排序是不稳定排序（等值元素可能交换位置）&lt;/li>
&lt;li>&lt;strong>递归深度&lt;/strong>：最坏情况递归深度O(n)，可通过尾递归优化&lt;/li>
&lt;li>&lt;strong>重复元素&lt;/strong>：当有大量重复元素时，可优化为三路快排&lt;/li>
&lt;/ol></description></item><item><title>C++ 中怎么给 map 自定义比较规则</title><link>https://muo123.github.io/articles/c-%E4%B8%AD%E6%80%8E%E4%B9%88%E7%BB%99-map-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</link><pubDate>Sun, 22 Jun 2025 19:29:57 +0800</pubDate><guid>https://muo123.github.io/articles/c-%E4%B8%AD%E6%80%8E%E4%B9%88%E7%BB%99-map-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</guid><description>&lt;p>在 C++ 中，&lt;code>std::map&lt;/code> 默认使用 &lt;code>std::less&amp;lt;Key&amp;gt;&lt;/code> 进行排序（升序）。若需自定义排序规则，可通过以下三种方式实现：&lt;/p>
&lt;h3 id="1-使用函数对象仿函数">1. 使用函数对象（仿函数）
&lt;/h3>&lt;p>定义包含 &lt;code>operator()&lt;/code> 的结构体/类，实现严格弱序比较：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">struct&lt;/span> &lt;span style="color:#f3f99d">CaseInsensitiveCompare&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#9aedfe">bool&lt;/span> &lt;span style="color:#57c7ff">operator&lt;/span>()(&lt;span style="color:#ff6ac1">const&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>string&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> a, &lt;span style="color:#ff6ac1">const&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>string&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> b) &lt;span style="color:#ff6ac1">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 不区分大小写比较
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#ff6ac1">return&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>lexicographical_compare(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.begin(), a.end(), b.begin(), b.end(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [](&lt;span style="color:#9aedfe">char&lt;/span> c1, &lt;span style="color:#9aedfe">char&lt;/span> c2) { &lt;span style="color:#ff6ac1">return&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>tolower(c1) &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>tolower(c2); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span> &lt;span style="color:#57c7ff">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#ff6ac1">::&lt;/span>map&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>std&lt;span style="color:#ff6ac1">::&lt;/span>string, &lt;span style="color:#9aedfe">int&lt;/span>, CaseInsensitiveCompare&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> myMap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#5af78e">&amp;#34;Apple&amp;#34;&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#5af78e">&amp;#34;banana&amp;#34;&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#5af78e">&amp;#34;apple&amp;#34;&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">3&lt;/span>; &lt;span style="color:#78787e">// 覆盖 &amp;#34;Apple&amp;#34;（不区分大小写）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">for&lt;/span> (&lt;span style="color:#ff6ac1">const&lt;/span> &lt;span style="color:#ff6ac1">auto&lt;/span>&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> &lt;span style="color:#ff5c57">kv&lt;/span> : myMap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#ff6ac1">::&lt;/span>cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> kv.first &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> kv.second &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 输出: apple: 3, banana: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-使用函数指针适用于简单规则">2. 使用函数指针（适用于简单规则）
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">bool&lt;/span> &lt;span style="color:#57c7ff">reverseCompare&lt;/span>(&lt;span style="color:#9aedfe">int&lt;/span> a, &lt;span style="color:#9aedfe">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">return&lt;/span> a &lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> b; &lt;span style="color:#78787e">// 降序排列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span> &lt;span style="color:#57c7ff">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 模板参数传入函数指针类型，构造函数传入函数指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>map&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>&lt;span style="color:#9aedfe">int&lt;/span>, std&lt;span style="color:#ff6ac1">::&lt;/span>string, &lt;span style="color:#ff6ac1">decltype&lt;/span>(&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span>reverseCompare)&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> myMap(reverseCompare);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#ff9f43">1&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#5af78e">&amp;#34;one&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#ff9f43">3&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#5af78e">&amp;#34;three&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#ff9f43">2&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#5af78e">&amp;#34;two&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">for&lt;/span> (&lt;span style="color:#ff6ac1">const&lt;/span> &lt;span style="color:#ff6ac1">auto&lt;/span>&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> &lt;span style="color:#ff5c57">kv&lt;/span> : myMap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#ff6ac1">::&lt;/span>cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> kv.first &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> kv.second &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 输出: 3: three, 2: two, 1: one
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-使用-lambda-表达式c11-起">3. 使用 Lambda 表达式（C++11 起）
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#78787e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">#include&lt;/span> &lt;span style="color:#78787e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#78787e"> &lt;/span>&lt;span style="color:#78787e">// 需包含 std::function
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">int&lt;/span> &lt;span style="color:#57c7ff">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">auto&lt;/span> comp &lt;span style="color:#ff6ac1">=&lt;/span> [](&lt;span style="color:#ff6ac1">const&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>string&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> a, &lt;span style="color:#ff6ac1">const&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>string&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">return&lt;/span> a.length() &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> b.length(); &lt;span style="color:#78787e">// 按字符串长度排序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 使用 decltype 推导 Lambda 类型，构造时传入 Lambda 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>map&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>std&lt;span style="color:#ff6ac1">::&lt;/span>string, &lt;span style="color:#9aedfe">int&lt;/span>, &lt;span style="color:#ff6ac1">decltype&lt;/span>(comp)&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> myMap(comp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#5af78e">&amp;#34;dog&amp;#34;&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#5af78e">&amp;#34;elephant&amp;#34;&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myMap[&lt;span style="color:#5af78e">&amp;#34;cat&amp;#34;&lt;/span>] &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">for&lt;/span> (&lt;span style="color:#ff6ac1">const&lt;/span> &lt;span style="color:#ff6ac1">auto&lt;/span>&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> &lt;span style="color:#ff5c57">kv&lt;/span> : myMap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#ff6ac1">::&lt;/span>cout &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> kv.first &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> kv.second &lt;span style="color:#ff6ac1">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#5af78e">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#78787e">// 输出（按长度升序）:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#78787e">// cat: 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#78787e">// dog: 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> &lt;span style="color:#78787e">// elephant: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="关键注意事项">关键注意事项：
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>严格弱序要求&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>必须满足：&lt;code>!comp(a, a)&lt;/code>（反自反）&lt;/li>
&lt;li>若 &lt;code>comp(a, b) == true&lt;/code>，则 &lt;code>comp(b, a) == false&lt;/code>（非对称）&lt;/li>
&lt;li>若 &lt;code>comp(a, b) &amp;amp;&amp;amp; comp(b, c)&lt;/code>，则 &lt;code>comp(a, c)&lt;/code>（传递性）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>自定义类型作为 Key&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">struct&lt;/span> &lt;span style="color:#f3f99d">Point&lt;/span> { &lt;span style="color:#9aedfe">int&lt;/span> x; &lt;span style="color:#9aedfe">int&lt;/span> y; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff6ac1">struct&lt;/span> &lt;span style="color:#f3f99d">PointCompare&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#9aedfe">bool&lt;/span> &lt;span style="color:#57c7ff">operator&lt;/span>()(&lt;span style="color:#ff6ac1">const&lt;/span> Point&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> a, &lt;span style="color:#ff6ac1">const&lt;/span> Point&lt;span style="color:#ff6ac1">&amp;amp;&lt;/span> b) &lt;span style="color:#ff6ac1">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">return&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>tie(a.x, a.y) &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> std&lt;span style="color:#ff6ac1">::&lt;/span>tie(b.x, b.y); &lt;span style="color:#78787e">// 先比较x，后比较y
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#78787e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#ff6ac1">::&lt;/span>map&lt;span style="color:#ff6ac1">&amp;lt;&lt;/span>Point, &lt;span style="color:#9aedfe">int&lt;/span>, PointCompare&lt;span style="color:#ff6ac1">&amp;gt;&lt;/span> pointMap;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能考虑&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>比较函数应尽量简单高效（频繁调用）&lt;/li>
&lt;li>避免在比较函数中修改状态（应为无状态的）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>与 &lt;code>unordered_map&lt;/code> 区别&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>std::map&lt;/code> 使用比较器确定红黑树中的顺序&lt;/li>
&lt;li>&lt;code>std::unordered_map&lt;/code> 自定义排序需特化 &lt;code>std::hash&lt;/code> 并提供相等比较函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>通过自定义比较规则，可以灵活控制 &lt;code>std::map&lt;/code> 中元素的排序行为，适应不同场景需求。&lt;/p></description></item><item><title>判断质数 C++ 实现</title><link>https://muo123.github.io/articles/%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0-c-%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 21 Jun 2025 18:59:18 +0800</pubDate><guid>https://muo123.github.io/articles/%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0-c-%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>要判断一个数是否为质数，可以遵循以下思路：质数是大于1且只能被1和自身整除的自然数。算法关键在于高效地检查该数是否有除1和自身外的其他因数。&lt;/p>
&lt;h3 id="算法思路">算法思路
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>处理边界情况&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>若数字小于2，则不是质数（质数定义要求大于1）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>检查奇数因子&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>只需检查从2开始的奇数因子。&lt;/li>
&lt;li>检查范围上限为 $\sqrt{n}$（数学原理：若 $n$ 有因子 $a$，则必有因子 $b = n/a$，其中一个因子必小于等于 $\sqrt{n}$。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="时间复杂度">时间复杂度
&lt;/h3>&lt;ul>
&lt;li>最优情况：$O(1)$（如偶数或小质数）。&lt;/li>
&lt;li>最坏情况：$O(\sqrt{n})$（需遍历到 $\sqrt{n}$。&lt;/li>
&lt;/ul>
&lt;h3 id="c-代码实现">C++ 代码实现
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#9aedfe">bool&lt;/span> &lt;span style="color:#57c7ff">is_prime&lt;/span>(&lt;span style="color:#9aedfe">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">if&lt;/span>(n &lt;span style="color:#ff6ac1">&amp;lt;&lt;/span> &lt;span style="color:#ff9f43">2&lt;/span>) &lt;span style="color:#ff6ac1">return&lt;/span> &lt;span style="color:#ff5c57">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">for&lt;/span>(&lt;span style="color:#9aedfe">int&lt;/span> i &lt;span style="color:#ff6ac1">=&lt;/span> &lt;span style="color:#ff9f43">2&lt;/span>; i &lt;span style="color:#ff6ac1">&amp;lt;=&lt;/span> n&lt;span style="color:#ff6ac1">/&lt;/span>i; i&lt;span style="color:#ff6ac1">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">if&lt;/span>(n &lt;span style="color:#ff6ac1">%&lt;/span> i &lt;span style="color:#ff6ac1">==&lt;/span> &lt;span style="color:#ff9f43">0&lt;/span>) &lt;span style="color:#ff6ac1">return&lt;/span> &lt;span style="color:#ff5c57">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff6ac1">return&lt;/span> &lt;span style="color:#ff5c57">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码解释">代码解释
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>边界处理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>n &amp;lt; 2&lt;/code>：直接返回 &lt;code>false&lt;/code>。&lt;/li>
&lt;li>&lt;code>n == 2&lt;/code>：唯一偶质数，返回 &lt;code>true&lt;/code>。&lt;/li>
&lt;li>&lt;code>n % 2 == 0&lt;/code>：除2外的偶数均不是质数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>因子检查&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>计算上限&lt;/strong>：&lt;code>i &amp;lt;= n/i&lt;/code> 确保覆盖所有可能因子。&lt;/li>
&lt;li>&lt;strong>找到因子&lt;/strong>：若整除成立，则 &lt;code>n&lt;/code> 不是质数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>返回结果&lt;/strong>：若循环结束未找到因子，则 &lt;code>n&lt;/code> 是质数。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="示例测试">示例测试
&lt;/h3>&lt;ul>
&lt;li>&lt;code>isPrime(2) → true&lt;/code>&lt;/li>
&lt;li>&lt;code>isPrime(17) → true&lt;/code>&lt;/li>
&lt;li>&lt;code>isPrime(9) → false&lt;/code>&lt;/li>
&lt;li>&lt;code>isPrime(1) → false&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>此算法平衡了效率与简洁性，适用于大多数场景。对于极大数字（如密码学应用），可采用更高级算法（如Miller-Rabin测试）。&lt;/p></description></item></channel></rss>